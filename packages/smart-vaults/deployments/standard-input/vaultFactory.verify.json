{"language":"Solidity","sources":{"src/vault/SmartVaultFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { MultiSignerLib } from \"../signers/MultiSigner.sol\";\nimport { Signer } from \"../signers/Signer.sol\";\nimport { SmartVault } from \"./SmartVault.sol\";\n\nimport { LibClone } from \"solady/utils/LibClone.sol\";\n\n/**\n * @title Splits Smart Accounts/Vaults Factory\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n * @notice based on Coinbase's Smart Wallet Factory.\n */\ncontract SmartVaultFactory {\n    /* -------------------------------------------------------------------------- */\n    /*                                  CONSTANTS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Address of the ERC-4337 implementation used as implementation for new accounts.\n    address public immutable IMPLEMENTATION;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Event emitted when a new smart vault/account is created.\n    event SmartVaultCreated(address indexed vault, address owner, Signer[] signers, uint8 threshold, uint256 salt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    constructor() payable {\n        IMPLEMENTATION = address(new SmartVault());\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                          EXTERNAL/PUBLIC FUNCTIONS                         */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Returns the deterministic address for a Splits Smart Vault created with `owner`, `signers`, 'threshold',\n     * `salt`. Deploys and initializes contract if it has not yet been created.\n     *\n     * @dev Deployed as an ERC-1967 proxy.\n     *\n     * @param owner_ Owner of the smart vault.\n     * @param signers_ Array of initial signers. Each signer is of type `Signer`.\n     * @param threshold_ Number of signers needed for a valid userOp/signature.\n     * @param salt_  The salt of the account, a caller defined value which allows multiple accounts\n     *               with the same `owner`, `signers` and `threshold` to exist at different addresses.\n     *\n     * @return account The address of the ERC-1967 proxy created.\n     */\n    function createAccount(\n        address owner_,\n        Signer[] calldata signers_,\n        uint8 threshold_,\n        uint256 salt_\n    )\n        external\n        payable\n        virtual\n        returns (SmartVault account)\n    {\n        (bool alreadyDeployed, address accountAddress) = LibClone.createDeterministicERC1967(\n            msg.value, IMPLEMENTATION, _getSalt(owner_, signers_, threshold_, salt_)\n        );\n\n        account = SmartVault(payable(accountAddress));\n\n        if (!alreadyDeployed) {\n            account.initialize(owner_, signers_, threshold_);\n\n            emit SmartVaultCreated({\n                vault: accountAddress,\n                owner: owner_,\n                signers: signers_,\n                threshold: threshold_,\n                salt: salt_\n            });\n        }\n    }\n\n    /**\n     * @notice Returns the deterministic address of the account that would be created by `createAccount`.\n     *\n     * @dev Reverts when the initial configuration of signers is invalid.\n     *\n     * @param owner_ Owner of the smart vault.\n     * @param signers_ Array of initial signers. Each signer is of type `Signer`.\n     * @param threshold_ Number of signers needed for a valid userOp/signature.\n     * @param salt_  The salt provided to `createAccount()`.\n     *\n     * @return The predicted account deployment address.\n     */\n    function getAddress(\n        address owner_,\n        Signer[] calldata signers_,\n        uint8 threshold_,\n        uint256 salt_\n    )\n        external\n        view\n        returns (address)\n    {\n        MultiSignerLib.validateSigners(signers_, threshold_);\n        return LibClone.predictDeterministicAddress(\n            initCodeHash(), _getSalt(owner_, signers_, threshold_, salt_), address(this)\n        );\n    }\n\n    /**\n     * @notice Returns the initialization code hash of the account:\n     *         a ERC1967 proxy that's implementation is `IMPLEMENTATION`.\n     *\n     * @return The initialization code hash.\n     */\n    function initCodeHash() public view virtual returns (bytes32) {\n        return LibClone.initCodeHashERC1967(IMPLEMENTATION);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                          INTERNAL/PRIVATE FUNCTION                         */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Returns the create2 salt for `LibClone.predictDeterministicAddress`\n    function _getSalt(\n        address owner_,\n        Signer[] calldata signers_,\n        uint8 threshold_,\n        uint256 salt_\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(owner_, signers_, threshold_, salt_));\n    }\n}\n"},"src/signers/MultiSigner.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { Signer } from \"../signers/Signer.sol\";\n\n/**\n * @notice Multi Signer struct.\n * @dev Each signer is of type `Signer`.\n * @dev Can allow up to 256 signers.\n */\nstruct MultiSigner {\n    /// @dev Number of unique signatures required to validate a message signed by this contract.\n    uint8 threshold;\n    /// @dev number of signers\n    uint8 signerCount;\n    /// @dev signers of type `Signer`;\n    Signer[256] signers;\n}\n\nusing MultiSignerLib for MultiSigner global;\n\n/**\n * @title Multi Signer Library\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n */\nlibrary MultiSignerLib {\n    /* -------------------------------------------------------------------------- */\n    /*                                   STRUCTS                                  */\n    /* -------------------------------------------------------------------------- */\n\n    struct SignatureWrapper {\n        /// @dev The index of the signer that signed, see `MultiSigner.signerAtIndex`\n        uint8 signerIndex;\n        /**\n         * @dev If `MultiSigner.signerAtIndex` is an Ethereum address, this should be `abi.encodePacked(r, s, v)`\n         *      If `MultiSigner.signerAtIndex` is a public key, this should be `abi.encode(WebAuthnAuth)`.\n         */\n        bytes signatureData;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   ERRORS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Thrown when Signer is invalid.\n    error InvalidSigner(Signer signer);\n\n    /// @notice Thrown when threshold is greater than number of owners or when zero.\n    error InvalidThreshold();\n\n    /// @notice Thrown when number of signers is more than 256.\n    error InvalidNumberOfSigners();\n\n    /**\n     * @notice Thrown when trying to remove an empty signer.\n     * @param index Index of the empty signer.\n     */\n    error SignerNotPresent(uint8 index);\n\n    /**\n     * @notice Thrown when trying to replace an existing signer.\n     * @param index Index of the existing signer.\n     */\n    error SignerAlreadyPresent(uint8 index);\n\n    /**\n     * @notice Thrown when same signer is used for signature verification.\n     * @param index Index of duplicate signer.\n     */\n    error DuplicateSigner(uint8 index);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  FUNCTIONS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Get signer at index from storage.\n    function getSigner(MultiSigner storage $_, uint8 index_) internal view returns (Signer memory) {\n        return $_.signers[index_];\n    }\n\n    /// @notice Get threshold from storage.\n    function getThreshold(MultiSigner storage $_) internal view returns (uint8) {\n        return $_.threshold;\n    }\n\n    /// @notice Get number of signers from storage.\n    function getSignerCount(MultiSigner storage $_) internal view returns (uint8) {\n        return $_.signerCount;\n    }\n\n    /**\n     * @notice Adds signer at index in storage.\n     *\n     * @dev Throws error when a signer is already present at index.\n     * @dev Throws error when signer is not EOA or Passkey.\n     *\n     * @param $_ Multi signer storage reference.\n     * @param signer_ Signer to be set.\n     * @param index_ Index to set signer at.\n     */\n    function addSigner(MultiSigner storage $_, Signer calldata signer_, uint8 index_) internal {\n        if (!$_.signers[index_].isEmptyMem()) revert SignerAlreadyPresent(index_);\n\n        _addSigner($_, signer_, index_);\n\n        $_.signerCount = $_.signerCount + 1;\n    }\n\n    /**\n     * @notice Removes signer at the given `index`.\n     *\n     * @dev Reverts if 'threshold' is equal to signer count.\n     * @dev Reverts if signer is empty at `index`.\n     *\n     * @param $_ Multi signer storage reference.\n     * @param index_ The index of the signer to be removed.\n     * @return signer Signer being removed.\n     */\n    function removeSigner(MultiSigner storage $_, uint8 index_) internal returns (Signer memory signer) {\n        uint8 signerCount = $_.signerCount;\n\n        if (signerCount == $_.threshold) revert InvalidThreshold();\n\n        signer = $_.signers[index_];\n\n        if (signer.isEmptyMem()) revert SignerNotPresent(index_);\n\n        delete $_.signers[index_];\n        $_.signerCount = signerCount - 1;\n    }\n\n    /**\n     * @notice Updates threshold of the signer set.\n     *\n     * @dev Reverts if 'threshold' is greater than signer count.\n     * @dev Reverts if 'threshold' is 0.\n     *\n     * @param $_ Multi signer storage reference.\n     * @param threshold_ The new signer set threshold.\n     */\n    function updateThreshold(MultiSigner storage $_, uint8 threshold_) internal {\n        if (threshold_ == 0) revert InvalidThreshold();\n\n        if ($_.signerCount < threshold_) revert InvalidThreshold();\n\n        $_.threshold = threshold_;\n    }\n\n    /**\n     * @notice Initialize the signers.\n     *\n     * @dev Intended to be called when initializing the signer set.\n     * @dev Reverts if signer is neither an EOA or a passkey.\n     * @dev Reverts if 'threshold' is less than number of signers.\n     * @dev Reverts if 'threshold' is 0.\n     * @dev Reverts if number of signers is more than 256.\n     *\n     * @param signers_ The initial set of signers.\n     * @param threshold_ The number of signers needed for approval.\n     */\n    function initializeSigners(MultiSigner storage $_, Signer[] calldata signers_, uint8 threshold_) internal {\n        if (signers_.length > type(uint8).max) revert InvalidNumberOfSigners();\n\n        uint8 numSigners = uint8(signers_.length);\n\n        if (numSigners < threshold_ || threshold_ < 1) revert InvalidThreshold();\n\n        for (uint8 i; i < numSigners; i++) {\n            _addSigner($_, signers_[i], i);\n        }\n\n        $_.signerCount = numSigners;\n        $_.threshold = threshold_;\n    }\n\n    /// @dev reverts if signer is neither an EOA or a Passkey.\n    /// @dev replaces signer at `index`. Should be used with proper checks.\n    function _addSigner(MultiSigner storage $_, Signer calldata signer_, uint8 index_) private {\n        if (signer_.isPasskey()) {\n            /// if passkey store signer as is.\n            $_.signers[index_] = signer_;\n        } else if (signer_.isEOA()) {\n            /// if EOA only store slot1 since slot2 is zero.\n            $_.signers[index_].slot1 = signer_.slot1;\n        } else {\n            revert InvalidSigner(signer_);\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              VALIDATE SIGNERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Validates the list of `signers` and `threshold`.\n     *\n     * @dev Throws error when number of signers is zero or greater than 255.\n     * @dev Throws error if `threshold` is zero or greater than number of signers.\n     *\n     * @param signers_ List of Signer(s).\n     * @param threshold_ minimum number of signers required for approval.\n     */\n    function validateSigners(Signer[] calldata signers_, uint8 threshold_) internal pure {\n        if (signers_.length > type(uint8).max) revert InvalidNumberOfSigners();\n\n        uint8 numberOfSigners = uint8(signers_.length);\n\n        if (numberOfSigners < threshold_ || threshold_ < 1) revert InvalidThreshold();\n\n        for (uint8 i; i < numberOfSigners; i++) {\n            validateSigner(signers_[i]);\n        }\n    }\n\n    /**\n     * @notice Validates the signer.\n     *\n     * @dev Throws error when signer is neither an EOA or a passkey.\n     */\n    function validateSigner(Signer calldata signer_) internal pure {\n        if (!signer_.isValid()) revert InvalidSigner(signer_);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             VALIDATE SIGNATURES                            */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice validates if `hash_` was signed by the signer set present in `$_`\n     *\n     * @param $_ Multi signer storage reference.\n     * @param hash_ blob of data that needs to be verified.\n     * @param signatures_ List of signatureWrapper.\n     */\n    function isValidSignature(\n        MultiSigner storage $_,\n        bytes32 hash_,\n        SignatureWrapper[] memory signatures_\n    )\n        internal\n        view\n        returns (bool isValid)\n    {\n        return isValidSignature($_, hash_, hash_, signatures_);\n    }\n\n    /**\n     * @notice validates if a pair of hashes was signed by the signer set present in `$_`.\n     *\n     * @param $_ Multi signer storage reference.\n     * @param frontHash_ blob of data that should be signed by all but the last signer.\n     * @param backHash_ blob of data that should be signed by the last signer.\n     * @param signatures_ List of signatureWrapper.\n     */\n    function isValidSignature(\n        MultiSigner storage $_,\n        bytes32 frontHash_,\n        bytes32 backHash_,\n        SignatureWrapper[] memory signatures_\n    )\n        internal\n        view\n        returns (bool isValid)\n    {\n        isValid = true;\n\n        uint8 threshold = $_.threshold;\n\n        uint256 alreadySigned;\n\n        uint256 mask;\n        uint8 signerIndex;\n        uint256 i;\n        for (; i < threshold - 1; i++) {\n            signerIndex = signatures_[i].signerIndex;\n            mask = (1 << signerIndex);\n\n            if (alreadySigned & mask != 0) revert DuplicateSigner(signerIndex);\n\n            if ($_.signers[signerIndex].isValidSignature(frontHash_, signatures_[i].signatureData)) {\n                alreadySigned |= mask;\n            } else {\n                isValid = false;\n            }\n        }\n\n        signerIndex = signatures_[i].signerIndex;\n        mask = (1 << signerIndex);\n\n        if (alreadySigned & mask != 0) revert DuplicateSigner(signerIndex);\n\n        if ($_.signers[signerIndex].isValidSignature(backHash_, signatures_[i].signatureData)) {\n            alreadySigned |= mask;\n        } else {\n            isValid = false;\n        }\n    }\n}\n"},"src/signers/Signer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { decodeAccountSigner } from \"./AccountSigner.sol\";\nimport { decodePasskeySigner } from \"./PasskeySigner.sol\";\n\n/**\n * @notice An EOA or Passkey signer.\n *\n * @dev For a Signer to be valid it has to be either an EOA or a Passkey signer.\n *      - EOA -> slot2 has to be empty and slot1 has to be a valid address.\n *      - Passkey -> slot2 has to be non empty.\n */\nstruct Signer {\n    bytes32 slot1;\n    bytes32 slot2;\n}\n\nusing SignerLib for Signer global;\n\n/**\n * @notice Signer library\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org/)\n */\nlibrary SignerLib {\n    /* -------------------------------------------------------------------------- */\n    /*                                  CONSTANTS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @dev bytes32(0).\n    bytes32 constant ZERO = bytes32(0);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   ERRORS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Thrown when signer is neither EOA or Passkey.\n    error InvalidSigner();\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  FUNCTIONS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice checks if slot2 is zero and slot1 is a valid address.\n    function isEOA(Signer calldata signer_) internal pure returns (bool) {\n        uint256 slot1 = uint256(bytes32(signer_.slot1));\n        return signer_.slot2 == ZERO && slot1 <= type(uint160).max && slot1 > 0;\n    }\n\n    /// @notice checks if slot2 is zero and slot1 is a valid address.\n    function isEOAMem(Signer memory signer_) internal pure returns (bool) {\n        uint256 slot1 = uint256(bytes32(signer_.slot1));\n        return signer_.slot2 == ZERO && slot1 <= type(uint160).max && slot1 > 0;\n    }\n\n    /**\n     * @dev slot2 will always be non zero for a passkey.\n     * ref: https://crypto.stackexchange.com/questions/108238/could-a-ec-public-key-have-zero-coordinate/108242#108242\n     */\n    function isPasskey(Signer calldata signer_) internal pure returns (bool) {\n        return signer_.slot2 != ZERO;\n    }\n\n    /**\n     * @dev slot2 will always be non zero for a passkey.\n     * ref: https://crypto.stackexchange.com/questions/108238/could-a-ec-public-key-have-zero-coordinate/108242#108242\n     */\n    function isPasskeyMem(Signer memory signer_) internal pure returns (bool) {\n        return signer_.slot2 != ZERO;\n    }\n\n    /// @notice Signer is considered valid if it is an EOA or a Passkey.\n    function isValid(Signer calldata signer_) internal pure returns (bool) {\n        return isEOA(signer_) || isPasskey(signer_);\n    }\n\n    /// @notice Returns true if both slot1 and slot2 are zero.\n    function isEmptyMem(Signer memory signer_) internal pure returns (bool) {\n        return signer_.slot1 == ZERO && signer_.slot2 == ZERO;\n    }\n\n    /// @notice validates if the signature provided by the signer is valid for the hash.\n    function isValidSignature(\n        Signer memory signer_,\n        bytes32 hash_,\n        bytes memory signature_\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (isPasskeyMem(signer_)) {\n            return decodePasskeySigner(signer_).isValidSignature(hash_, signature_);\n        } else if (isEOAMem(signer_)) {\n            return decodeAccountSigner(signer_).isValidSignature(hash_, signature_);\n        } else {\n            revert InvalidSigner();\n        }\n    }\n}\n"},"src/vault/SmartVault.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { UserOperationLib } from \"../library/UserOperationLib.sol\";\nimport { MultiSignerLib } from \"../signers/MultiSigner.sol\";\nimport { Signer } from \"../signers/Signer.sol\";\nimport { ERC1271 } from \"../utils/ERC1271.sol\";\nimport { FallbackManager } from \"../utils/FallbackManager.sol\";\nimport { ModuleManager } from \"../utils/ModuleManager.sol\";\nimport { MultiSignerAuth } from \"../utils/MultiSignerAuth.sol\";\n\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IAccount } from \"account-abstraction/interfaces/IAccount.sol\";\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\nimport { Ownable } from \"solady/auth/Ownable.sol\";\nimport { UUPSUpgradeable } from \"solady/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Splits Smart Accounts/Vaults\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n * @dev Based on Coinbase's Smart Wallet (https://github.com/coinbase/smart-wallet) and Solady's Smart Wallet.\n */\ncontract SmartVault is IAccount, Ownable, UUPSUpgradeable, MultiSignerAuth, ERC1271, FallbackManager, ModuleManager {\n    using UserOperationLib for PackedUserOperation;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   STRUCTS                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Primary Signature types\n    enum SignatureTypes {\n        SingleUserOp,\n        MerkelizedUserOp,\n        ERC1271\n    }\n\n    /// @notice Upper limits for maxPriorityFeePerGas, preVerificationGas, verificationGasLimit, callGasLimit,\n    /// paymasterVerificationGasLimit and paymasterPostOpGasLimit that should be charged by the userOp. This is included\n    /// in the light userOp hash to ensure last signer does not exceed the specified gas price/limits. These values will\n    /// be ignored when threshold is 1. paymaster, paymasterVerificationGasLimit and paymasterPostOpGasLimit will be\n    /// ignored if paymasterAndData is empty.\n    struct LightUserOpGasLimits {\n        uint256 maxPriorityFeePerGas;\n        uint256 preVerificationGas;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        address paymaster;\n        uint256 paymasterVerificationGasLimit;\n        uint256 paymasterPostOpGasLimit;\n    }\n\n    /// @notice Single User Op Signature Scheme.\n    struct SingleUserOpSignature {\n        /// @notice light user op gas limits.\n        LightUserOpGasLimits gasLimits;\n        /// @notice list of signatures where threshold - 1\n        /// signatures will be verified against the light userOp hash and the final signature will be verified\n        /// against the userOp hash.\n        MultiSignerLib.SignatureWrapper[] signatures;\n    }\n\n    /// @notice Merkelized User Op Signature Scheme.\n    struct MerkelizedUserOpSignature {\n        /// @notice light user op gas limits.\n        LightUserOpGasLimits gasLimits;\n        /// @notice merkleRoot of all the light(userOp) in the Merkle Tree. If threshold is 1, this will be\n        /// bytes32(0).\n        bytes32 lightMerkleTreeRoot;\n        /// @notice Proof to verify if the light userOp hash is present in the light merkle tree root. If\n        /// threshold is 1, this will be empty.\n        bytes32[] lightMerkleProof;\n        /// @notice merkleRoot of all the user ops in the Merkle Tree.\n        bytes32 merkleTreeRoot;\n        /// @notice Proof to verify if the userOp hash is present in the merkle tree.\n        bytes32[] merkleProof;\n        /// @notice list of signatures where threshold - 1\n        /// signatures will be verified against the `lightMerkleTreeRoot` and the final signature will be verified\n        /// against the `merkleTreeRoot`.\n        MultiSignerLib.SignatureWrapper[] signatures;\n    }\n\n    /// @notice ERC1271 Signature scheme\n    struct ERC1271Signature {\n        MultiSignerLib.SignatureWrapper[] signatures;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  CONSTANTS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Splits smart vaults factory.\n    address public immutable FACTORY;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   ERRORS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Thrown when caller is not entry point.\n    error OnlyEntryPoint();\n\n    /// @notice Thrown when caller is not factory.\n    error OnlyFactory();\n\n    /// @notice Thrown when caller is not address(this).\n    error OnlySelf();\n\n    /// @notice Thrown when contract creation has failed.\n    error FailedContractCreation();\n\n    /// @notice Thrown when Signature is of unknown type.\n    error InvalidSignatureType();\n\n    /// @notice Thrown when LightUserOpGasLimits have been breached.\n    error InvalidGasLimits();\n\n    /// @notice Thrown when Paymaster LightUserOpGasLimits have been breached.\n    error InvalidPaymasterData();\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  MODIFIERS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Reverts if the caller is not the EntryPoint.\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) {\n            revert OnlyEntryPoint();\n        }\n        _;\n    }\n\n    /// @notice Reverts if the caller is neither the EntryPoint or the owner.\n    modifier onlyEntryPointOrOwner() virtual {\n        if (msg.sender != entryPoint()) {\n            _checkOwner();\n        }\n        _;\n    }\n\n    /// @notice Reverts when caller is not this account.\n    modifier onlySelf() virtual {\n        if (msg.sender != address(this)) {\n            revert OnlySelf();\n        }\n        _;\n    }\n\n    /**\n     * @notice Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n     *\n     * @dev Subclass MAY override this modifier for better funds management (e.g. send to the\n     *      EntryPoint more than the minimum required, so that in future transactions it will not\n     *      be required to send again).\n     *\n     * @param missingAccountFunds_ The minimum value this modifier should send the EntryPoint which\n     *                            MAY be zero, in case there is enough deposit, or the userOp has a\n     *                            paymaster.\n     */\n    modifier payPrefund(uint256 missingAccountFunds_) virtual {\n        _;\n\n        assembly (\"memory-safe\") {\n            if missingAccountFunds_ {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds_, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    constructor() ERC1271(\"splitsSmartVault\", \"1\") {\n        FACTORY = msg.sender;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                          EXTERNAL/PUBLIC FUNCTIONS                         */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Initializes the account with the `signers` and `threshold`.\n     *\n     * @dev Reverts if caller is not factory.\n     * @dev Reverts if signers or threshold is invalid.\n     *\n     * @param owner_ Owner of the smart account.\n     * @param signers_ Array of initial signers. Each signer is of type `Signer`.\n     * @param threshold_ Number of signers required to approve a signature.\n     */\n    function initialize(address owner_, Signer[] calldata signers_, uint8 threshold_) external payable {\n        if (msg.sender != FACTORY) revert OnlyFactory();\n\n        _initializeOwner(owner_);\n        _initializeMultiSignerAuth(signers_, threshold_);\n    }\n\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     *\n     * @param userOp_              - The operation that is about to be executed.\n     * @param userOpHash_          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds_ - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp_,\n        bytes32 userOpHash_,\n        uint256 missingAccountFunds_\n    )\n        external\n        onlyEntryPoint\n        payPrefund(missingAccountFunds_)\n        returns (uint256 validationData)\n    {\n        SignatureTypes signatureType = _getSignatureType(userOp_.signature[0]);\n        bytes32 lightHash;\n\n        if (signatureType == SignatureTypes.SingleUserOp) {\n            SingleUserOpSignature memory signature = abi.decode(userOp_.signature[1:], (SingleUserOpSignature));\n\n            // if threshold is greater than 1, `threshold - 1` signers will sign over the light userOp hash. We lazily\n            // calculate light userOp hash based on number of signatures. If threshold is 1 then light userOp hash\n            // won't be needed.\n            if (signature.signatures.length > 1) {\n                _verifyGasLimits(userOp_, signature.gasLimits);\n                lightHash = _getLightUserOpHash(userOp_, signature.gasLimits);\n            }\n\n            return _validateSingleUserOp(lightHash, userOpHash_, signature);\n        } else if (signatureType == SignatureTypes.MerkelizedUserOp) {\n            MerkelizedUserOpSignature memory signature = abi.decode(userOp_.signature[1:], (MerkelizedUserOpSignature));\n\n            // if threshold is greater than 1, `threshold - 1` signers will sign over the merkle tree root of light user\n            // op hash(s). We lazily calculate light userOp hash based on number of signatures. If threshold\n            // is 1 then light userOp hash won't be needed.\n            if (signature.signatures.length > 1) {\n                _verifyGasLimits(userOp_, signature.gasLimits);\n                lightHash = _getLightUserOpHash(userOp_, signature.gasLimits);\n            }\n\n            return _validateMerkelizedUserOp(lightHash, userOpHash_, signature);\n        } else {\n            revert InvalidSignatureType();\n        }\n    }\n\n    /**\n     * @notice Executes the given call from this account.\n     *\n     * @dev Can only be called by the Entrypoint or owner of this account.\n     *\n     * @param call_ The `Call` to execute.\n     */\n    function execute(Call calldata call_) external payable onlyEntryPointOrOwner {\n        _call(call_);\n    }\n\n    /**\n     * @notice Executes batch of `Call`s.\n     *\n     * @dev Can only be called by the Entrypoint or owner of this account.\n     *\n     * @param calls_ The list of `Call`s to execute.\n     */\n    function executeBatch(Call[] calldata calls_) external payable onlyEntryPointOrOwner {\n        uint256 numCalls = calls_.length;\n        for (uint256 i; i < numCalls; i++) {\n            _call(calls_[i]);\n        }\n    }\n\n    /// @notice Returns the address of the EntryPoint v0.7.\n    function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n\n    /**\n     * @notice Returns the implementation of the ERC1967 proxy.\n     *\n     * @return implementation The address of implementation contract.\n     */\n    function getImplementation() public view returns (address implementation) {\n        assembly {\n            implementation := sload(_ERC1967_IMPLEMENTATION_SLOT)\n        }\n    }\n\n    /**\n     * @notice Forked from CreateX.\n     *\n     * @dev Deploys a new contract using the `CREATE` opcode and using the creation\n     * bytecode `initCode` and `msg.value` as inputs. In order to save deployment costs,\n     * we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero,\n     * `initCode` must have a `payable` constructor.\n     * @dev Can only be called by this contract.\n     * @dev Reverts when new contract is address(0) or code.length is zero.\n     *\n     * @param initCode_ The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate(bytes memory initCode_) external payable onlySelf returns (address newContract) {\n        assembly (\"memory-safe\") {\n            newContract := create(callvalue(), add(initCode_, 0x20), mload(initCode_))\n        }\n\n        if (newContract == address(0) || newContract.code.length == 0) {\n            revert FailedContractCreation();\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @dev authorizes caller to upgrade the implementation of this contract.\n    function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner { }\n\n    /// @dev authorizes caller to update signer set, fallback handlers and modules.\n    /// @dev can only be called by this contract.\n    function _authorize() internal view override(MultiSignerAuth, FallbackManager, ModuleManager) onlySelf { }\n\n    /**\n     * @dev Conditions for a valid owner check:\n     *      if owner is non zero, caller must be owner.\n     *      If owner is address(0), contract can call itself.\n     */\n    function _checkOwner() internal view override {\n        address owner;\n        address caller = msg.sender;\n\n        assembly (\"memory-safe\") {\n            owner := sload(_OWNER_SLOT)\n        }\n\n        if (owner == caller) return;\n        if (owner == address(0) && caller == address(this)) return;\n        revert Unauthorized();\n    }\n\n    /// @dev Get light userOp hash of the Packed user operation.\n    function _getLightUserOpHash(\n        PackedUserOperation calldata userOp_,\n        LightUserOpGasLimits memory gasLimits_\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(userOp_.hashLight(), gasLimits_, entryPoint(), block.chainid));\n    }\n\n    /// @dev validates if the given hash (ERC1271) was signed by the signers.\n    function _isValidSignature(bytes32 hash_, bytes calldata signature_) internal view override returns (bool) {\n        return _getMultiSignerStorage().isValidSignature(hash_, abi.decode(signature_, (ERC1271Signature)).signatures);\n    }\n\n    /// @dev validates single userOp signature.\n    function _validateSingleUserOp(\n        bytes32 lightHash_,\n        bytes32 userOpHash_,\n        SingleUserOpSignature memory signature\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _isValidSignature(lightHash_, userOpHash_, signature.signatures);\n    }\n\n    /**\n     * @dev validates merkelized userOp signature.\n     */\n    function _validateMerkelizedUserOp(\n        bytes32 lightHash_,\n        bytes32 userOpHash_,\n        MerkelizedUserOpSignature memory signature\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        bool isValidMerkleProof = MerkleProof.verify(signature.merkleProof, signature.merkleTreeRoot, userOpHash_);\n\n        if (signature.signatures.length > 1) {\n            isValidMerkleProof = isValidMerkleProof\n                && MerkleProof.verify(signature.lightMerkleProof, signature.lightMerkleTreeRoot, lightHash_);\n        }\n\n        uint256 isValidSig =\n            _isValidSignature(signature.lightMerkleTreeRoot, signature.merkleTreeRoot, signature.signatures);\n\n        return isValidMerkleProof ? isValidSig : UserOperationLib.INVALID_SIGNATURE;\n    }\n\n    function _isValidSignature(\n        bytes32 lightHash_,\n        bytes32 hash_,\n        MultiSignerLib.SignatureWrapper[] memory signatures\n    )\n        internal\n        view\n        returns (uint256 validationData)\n    {\n        return _getMultiSignerStorage().isValidSignature(lightHash_, hash_, signatures)\n            ? UserOperationLib.VALID_SIGNATURE\n            : UserOperationLib.INVALID_SIGNATURE;\n    }\n\n    function _getSignatureType(bytes1 signatureType_) internal pure returns (SignatureTypes) {\n        return SignatureTypes(uint8(signatureType_));\n    }\n\n    function _verifyGasLimits(\n        PackedUserOperation calldata userOp_,\n        LightUserOpGasLimits memory gasLimits_\n    )\n        internal\n        pure\n    {\n        (uint256 userOpMaxPriorityFeePerGas,) = UserOperationLib.unpackUints(userOp_.gasFees);\n        (uint256 verificationGasLimit, uint256 callGasLimit) = UserOperationLib.unpackUints(userOp_.accountGasLimits);\n\n        if (\n            userOpMaxPriorityFeePerGas > gasLimits_.maxPriorityFeePerGas || callGasLimit > gasLimits_.callGasLimit\n                || userOp_.preVerificationGas > gasLimits_.preVerificationGas\n                || verificationGasLimit > gasLimits_.verificationGasLimit\n        ) revert InvalidGasLimits();\n\n        if (userOp_.paymasterAndData.length > 0) {\n            (address paymaster, uint256 paymasterVerificationGasLimit, uint256 paymasterPostOpGasLimit) =\n                UserOperationLib.unpackPaymasterStaticFields(userOp_.paymasterAndData);\n\n            if (\n                gasLimits_.paymaster != paymaster\n                    || paymasterVerificationGasLimit > gasLimits_.paymasterVerificationGasLimit\n                    || paymasterPostOpGasLimit > gasLimits_.paymasterPostOpGasLimit\n            ) {\n                revert InvalidPaymasterData();\n            }\n        }\n    }\n}\n"},"node_modules/solady/src/utils/LibClone.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here implements a `receive()` method that emits the\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\n/// composability. The minimal proxy implementation does not offer this feature.\n///\n/// @dev Minimal ERC1967 proxy:\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\nlibrary LibClone {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or `by`.\n    error SaltDoesNotStartWith();\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This implementation of CWIA differs from the original implementation.\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\n        instance = clone(0, implementation, data);\n    }\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\n    function clone(uint256 value, address implementation, bytes memory data)\n        internal\n        returns (address instance)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 108`\n            // The `runSize` is `creationSize - 10`.\n\n            /**\n             * ---------------------------------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\n             * 81         | DUP2              | r 0 r     |                                                       |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\n             * ---------------------------------------------------------------------------------------------------|\n             * RUNTIME (98 bytes + extraLength)                                                                   |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\n             * ---------------------------------------------------------------------------------------------------|\n             *                                                                                                    |\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\n             * 57       | JUMPI          |                          |                                             |\n             * 34       | CALLVALUE      | cv                       |                                             |\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\n             * 5b       | JUMPDEST       |                          |                                             |\n             *                                                                                                    |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\n             *                                                                                                    |\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\n             * ---------------------------------------------------------------------------------------------------+\n             */\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `data` and `salt`.\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, data, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `data` and `salt`.\n    function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory data,\n        bytes32 salt\n    ) internal returns (address instance) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                sub(data, 0x5a),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    function deployERC1967(address implementation) internal returns (address instance) {\n        instance = deployERC1967(0, implementation);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (62 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the address when a contract with initialization code hash,\n    /// `hash`, is deployed with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\n    function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"src/signers/AccountSigner.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { Signer } from \"./Signer.sol\";\nimport { SignatureCheckerLib } from \"solady/utils/SignatureCheckerLib.sol\";\n\n/**\n * @notice A signer backed by an EOA or ERC-1271 smart account.\n */\ntype AccountSigner is address;\n\n/// @notice converts Signer to AccountSigner.\nfunction decodeAccountSigner(Signer memory signer_) pure returns (AccountSigner) {\n    return AccountSigner.wrap(address(uint160(uint256(signer_.slot1))));\n}\n\nusing AccountSignerLib for AccountSigner global;\n\n/**\n * @notice Library for verifying AccountSigner signatures.\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n */\nlibrary AccountSignerLib {\n    /* -------------------------------------------------------------------------- */\n    /*                                  FUNCTIONS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Verifies if the `signer` has signed the provided `messageHash`.\n     *\n     * @param signer_ Account signer.\n     * @param messageHash_ Message hash that should be signed by the signer.\n     * @param signature_ abi.encode(r,s,v) signature.\n     * @return isValid true when signer has signed the messageHash otherwise false.\n     */\n    function isValidSignature(\n        AccountSigner signer_,\n        bytes32 messageHash_,\n        bytes memory signature_\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return SignatureCheckerLib.isValidSignatureNow(\n            AccountSigner.unwrap(signer_), SignatureCheckerLib.toEthSignedMessageHash(messageHash_), signature_\n        );\n    }\n}\n"},"src/signers/PasskeySigner.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { Signer } from \"./Signer.sol\";\nimport { WebAuthn } from \"src/library/WebAuthn.sol\";\n\n/**\n * @notice A signer backed by a passkey.\n */\nstruct PasskeySigner {\n    uint256 x;\n    uint256 y;\n}\n\n/// @notice converts Signer to PasskeySigner.\nfunction decodePasskeySigner(Signer memory signer_) pure returns (PasskeySigner memory) {\n    return PasskeySigner(uint256(signer_.slot1), uint256(signer_.slot2));\n}\n\nusing PasskeySignerLib for PasskeySigner global;\n\n/**\n * @notice Library for verifying PasskeySigner signatures.\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n */\nlibrary PasskeySignerLib {\n    /* -------------------------------------------------------------------------- */\n    /*                                  FUNCTIONS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Verifies if the `signer` has signed the provided `messageHash`.\n     *\n     * @param signer_ Passkey signer.\n     * @param messageHash_ Message hash that should be signed by the signer.\n     * @param signature_ abi.encode(WebAuthn.WebAuthnAuth) signature.\n     * @return isValid true when signer has signed the messageHash otherwise false.\n     */\n    function isValidSignature(\n        PasskeySigner memory signer_,\n        bytes32 messageHash_,\n        bytes memory signature_\n    )\n        internal\n        view\n        returns (bool)\n    {\n        WebAuthn.WebAuthnAuth memory auth = abi.decode(signature_, (WebAuthn.WebAuthnAuth));\n\n        return WebAuthn.verify({\n            challenge: abi.encode(messageHash_),\n            requireUV: false,\n            webAuthnAuth: auth,\n            x: signer_.x,\n            y: signer_.y\n        });\n    }\n}\n"},"src/library/UserOperationLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\n/**\n * @title User operation Library\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n * @notice Forked from\n * https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/core/UserOperationLib.sol\n * @dev Light here refers to the subset of userOp params not related to gas, gas price or initCode in the userOp.\n */\nlibrary UserOperationLib {\n    /* -------------------------------------------------------------------------- */\n    /*                                  CONSTANTS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    uint256 public constant VALID_SIGNATURE = 0;\n\n    uint256 public constant INVALID_SIGNATURE = 1;\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  FUNCTIONS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice keccak function over calldata.\n     * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than\n     * letting solidity do it.\n     */\n    function calldataKeccak(bytes calldata data_) private pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data_.length\n            calldatacopy(mem, data_.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n    /**\n     * @notice Get sender from user operation data.\n     * @param userOp_ - The user operation data.\n     */\n    function getSender(PackedUserOperation calldata userOp_) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp_)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * @notice Pack the light user operation data into bytes for hashing.\n     * @dev Does not include the following properties of the User Op.\n     *  - initCode\n     *  - accountGasLimits\n     *  - preVerificationGas\n     *  - gasFees\n     *  - paymasterAndData\n     *  - signature\n     * @param userOp_ - The user operation data.\n     */\n    function encodeLight(PackedUserOperation calldata userOp_) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp_);\n        uint256 nonce = userOp_.nonce;\n        bytes32 hashCallData = calldataKeccak(userOp_.callData);\n\n        return abi.encode(sender, nonce, hashCallData);\n    }\n\n    /**\n     * @notice Hash light user operation data.\n     * @param userOp_ - The user operation data.\n     */\n    function hashLight(PackedUserOperation calldata userOp_) internal pure returns (bytes32) {\n        return keccak256(encodeLight(userOp_));\n    }\n\n    /**\n     * @notice Pack the user operation data into bytes for hashing.\n     * @param userOp_ - The user operation data.\n     */\n    function encode(PackedUserOperation calldata userOp_) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp_);\n        uint256 nonce = userOp_.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp_.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp_.callData);\n        bytes32 accountGasLimits = userOp_.accountGasLimits;\n        uint256 preVerificationGas = userOp_.preVerificationGas;\n        bytes32 gasFees = userOp_.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp_.paymasterAndData);\n\n        // solhint-disable\n        return abi.encode(\n            sender,\n            nonce,\n            hashInitCode,\n            hashCallData,\n            accountGasLimits,\n            preVerificationGas,\n            gasFees,\n            hashPaymasterAndData\n        );\n        // solhint-enable\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp_ - The user operation data.\n     */\n    function hash(PackedUserOperation calldata userOp_) internal pure returns (bytes32) {\n        return keccak256(encode(userOp_));\n    }\n\n    function unpackUints(bytes32 packed) internal pure returns (uint256 high128, uint256 low128) {\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\n    }\n\n    function unpackPaymasterStaticFields(bytes calldata paymasterAndData)\n        internal\n        pure\n        returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit)\n    {\n        return (\n            address(bytes20(paymasterAndData[:PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET:PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET:PAYMASTER_DATA_OFFSET]))\n        );\n    }\n}\n"},"src/utils/ERC1271.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\n/**\n * @title ERC-1271\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n * @notice Based on https://github.com/coinbase/smart-wallet/blob/main/src/ERC1271.sol\n * @notice Abstract ERC-1271 implementation (based on Solady's) with guards to handle the same\n *       signer being used on multiple accounts.\n */\nabstract contract ERC1271 is EIP712 {\n    /* -------------------------------------------------------------------------- */\n    /*                                  CONSTANTS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev We use `bytes32 hash` rather than `bytes message`\n     * In the EIP-712 context, `bytes message` would be useful for showing users a full message\n     * they are signing in some wallet preview. But in this case, to prevent replay\n     * across accounts, we are always dealing with nested messages, and so the\n     * input should be a EIP-191 or EIP-712 output hash.\n     * E.g. The input hash would be result of\n     *\n     *  keccak256(\"\\x19\\x01\" || someDomainSeparator || hashStruct(someStruct))\n     *\n     *  OR\n     *\n     * keccak256(\"\\x19Ethereum Signed Message:\\n\" || len(someMessage) || someMessage),\n     */\n    bytes32 private constant _MESSAGE_TYPEHASH = keccak256(\"SplitMessage(bytes32 hash)\");\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev Initializes the {EIP712} domain separator.\n     */\n    constructor(string memory name_, string memory version_) EIP712(name_, version_) { }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Validates the `signature` against the given `hash`.\n     *\n     * @dev This implementation follows ERC-1271. See https://eips.ethereum.org/EIPS/eip-1271.\n     * @dev IMPORTANT: Signature verification is performed on the hash produced AFTER applying the anti\n     *      cross-account-replay layer on the given `hash` (i.e., verification is run on the replay-safe\n     *      hash version).\n     *\n     * @param hash_      The original hash.\n     * @param signature_ The signature of the replay-safe hash to validate.\n     * @return result `0x1626ba7e` if validation succeeded, else `0xffffffff`.\n     */\n    function isValidSignature(bytes32 hash_, bytes calldata signature_) public view virtual returns (bytes4) {\n        if (_isValidSignature(replaySafeHash(hash_), signature_)) {\n            // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n            return 0x1626ba7e;\n        }\n\n        return 0xffffffff;\n    }\n\n    /**\n     * @dev Returns an EIP-712-compliant hash of `hash`,\n     * where the domainSeparator includes address(this) and block.chainId\n     * to protect against the same signature being used for many accounts.\n     *\n     * @param hash_ The original hash.\n     * @return\n     *  keccak256(\\x19\\x01 || this.domainSeparator ||\n     *      hashStruct(SplitWalletMessage({\n     *          hash: `hash`\n     *      }))\n     *  )\n     */\n    function replaySafeHash(bytes32 hash_) public view virtual returns (bytes32) {\n        return _hashTypedDataV4(keccak256(abi.encode(_MESSAGE_TYPEHASH, hash_)));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Validates the `signature` against the given `hash`.\n     *\n     * @dev MUST be defined by the implementation.\n     *\n     * @param hash_      The hash whose signature has been performed on.\n     * @param signature_ The signature associated with `hash`.\n     * @return `true` is the signature is valid, else `false`.\n     */\n    function _isValidSignature(bytes32 hash_, bytes calldata signature_) internal view virtual returns (bool);\n}\n"},"src/utils/FallbackManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { Receiver } from \"solady/accounts/Receiver.sol\";\n\n/**\n * @title Fallback Manager - Fallback call handler for a smart contract.\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n * @dev By defaults supports all ERC721 and ERC1155 token safety callbacks.\n */\nabstract contract FallbackManager is Receiver {\n    /* -------------------------------------------------------------------------- */\n    /*                                  CONSTANTS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev Slot for the `FallbackManager` struct in storage.\n     *      Computed from\n     *      keccak256(abi.encode(uint256(keccak256(\"splits.storage.fallbackManager\")) - 1)) & ~bytes32(uint256(0xff))\n     *      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n     */\n    bytes32 internal constant _FALLBACK_MANAGER_STORAGE_SLOT =\n        0xb944faae3883660fcc8ae340f6a7654d66dcad30db4f2f608a0b893e0f339a00;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   STRUCTS                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Fallback Manager storage structure\n    /// @custom:storage-location erc7201:splits.storage.fallbackManager\n    struct FallbackManagerStorage {\n        mapping(bytes4 => address) fallbackHandler;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Event emitted when a new Fallback Handler is registered.\n    event UpdatedFallbackHandler(bytes4 indexed sig, address indexed handler);\n\n    /// @notice Event emitted when this contract receives ETH.\n    event ReceiveEth(address indexed sender, uint256 amount);\n\n    /// @notice Event emitted when a call is made to a fallback handler.\n    event FallbackHandlerCalled(\n        address indexed sender, address indexed handler, bytes data, bool success, bytes result\n    );\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   ERRORS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Thrown when a function is not supported by the FallbackHandler.\n    error FunctionNotSupported(bytes4 sig);\n\n    /* -------------------------------------------------------------------------- */\n    /*                          EXTERNAL/PUBLIC FUNCTIONS                         */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev Fallback function to handle unsupported function calls.\n     * It checks if a handler is set for the given function signature and\n     * if so, forwards the call to the handler.\n     */\n    fallback() external payable override receiverFallback {\n        address handler = _getFallbackManagerStorage().fallbackHandler[msg.sig];\n\n        if (handler == address(0)) {\n            revert FunctionNotSupported(msg.sig);\n        }\n\n        bytes calldata data = msg.data;\n\n        (bool success, bytes memory result) = handler.call(data);\n\n        emit FallbackHandlerCalled(msg.sender, handler, data, success, result);\n\n        if (!success) {\n            assembly (\"memory-safe\") {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        assembly (\"memory-safe\") {\n            return(add(result, 0x20), mload(result))\n        }\n    }\n\n    /// @notice Receive function that logs the amount of ETH received.\n    receive() external payable override {\n        emit ReceiveEth(msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Allows setting a handler for a given function signature.\n     *\n     * @dev Following signatures is handled automatically by this contract and does not need any handler.\n     *      - 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n     *      - 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n     *      - 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n     *\n     * @param sig_ The function signature for which the handler is being set.\n     * @param handler_ The address of the handler contract.\n     */\n    function updateFallbackHandler(bytes4 sig_, address handler_) external {\n        _authorize();\n\n        _getFallbackManagerStorage().fallbackHandler[sig_] = handler_;\n\n        emit UpdatedFallbackHandler(sig_, handler_);\n    }\n\n    /**\n     * @notice Returns the fallback handler associated with the provided `sig`.\n     * @param sig_ bytes4 signature.\n     * @return handler address of contract that receives the call for `sig`.\n     */\n    function getFallbackHandler(bytes4 sig_) public view returns (address) {\n        return _getFallbackManagerStorage().fallbackHandler[sig_];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                         INTERNAL/PRIVATE FUNCTIONS                         */\n    /* -------------------------------------------------------------------------- */\n\n    function _authorize() internal view virtual;\n\n    function _getFallbackManagerStorage() internal pure returns (FallbackManagerStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := _FALLBACK_MANAGER_STORAGE_SLOT\n        }\n    }\n}\n"},"src/utils/ModuleManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { Caller } from \"./Caller.sol\";\n\n/**\n * @title Module Manager\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n * @notice Manages modules of a smart contract. Gives each module the ability to execute `Calls` from this account.\n * @dev Account owners should be careful when adding a module.\n */\nabstract contract ModuleManager is Caller {\n    /* -------------------------------------------------------------------------- */\n    /*                                  CONSTANTS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev Slot for the `ModuleManager` struct in storage.\n     *      Computed from\n     *      keccak256(abi.encode(uint256(keccak256(\"splits.storage.moduleManager\")) - 1)) & ~bytes32(uint256(0xff))\n     *      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n     */\n    bytes32 internal constant _MODULE_MANAGER_STORAGE_SLOT =\n        0xe103b19f601cd46db3208af0dd24bb7e0acd21ca997b18cc4246bfe5258d3800;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   STRUCTS                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Module Manager storage structure.\n    /// @custom:storage-location erc7201:splits.storage.moduleManager\n    struct ModuleManagerStorage {\n        mapping(address => bool) isModule;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Event emitted when an module is enabled.\n    event EnabledModule(address indexed module);\n\n    /// @notice Event emitted when an module is disabled.\n    event DisabledModule(address indexed module);\n\n    /// @notice Event emitted when an module executes a call.\n    event ExecutedTxFromModule(address indexed module, Call call);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   ERRORS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Thrown when caller is not an module.\n    error OnlyModule();\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  MODIFIERS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    modifier onlyModule() {\n        if (!_getModuleManagerStorage().isModule[msg.sender]) revert OnlyModule();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                          EXTERNAL/PUBLIC FUNCTIONS                         */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Adds `module` to the allowlist.\n     *\n     * @dev access is controlled by `_authorize()`.\n     *\n     * @param module_ address of module.\n     */\n    function enableModule(address module_) external {\n        _authorize();\n\n        _enableModule(module_);\n    }\n\n    /**\n     * @notice Adds `module` to the allowlist and makes a call to the `setupContract` passing `data_`.\n     *\n     * @dev access is controlled by `_authorize()`.\n     *\n     * @param module_ address of module.\n     * @param setupContract_ address of contract to call to setup module.\n     * @param data_ data passed to the setupContract.\n     */\n    function setupAndEnableModule(address module_, address setupContract_, bytes calldata data_) external {\n        _authorize();\n\n        _enableModule(module_);\n\n        _call(setupContract_, 0, data_);\n    }\n\n    /**\n     * @notice Removes module from the allowlist.\n     *\n     * @dev access is controlled by `_authorize()`.\n     *\n     * @param module_ address of module.\n     */\n    function disableModule(address module_) external {\n        _authorize();\n\n        _disableModule(module_);\n    }\n\n    /**\n     * @notice Removes `module` from the allowlist and makes a call to the `teardownContract_` passing `data_`.\n     *\n     * @dev access is controlled by `_authorize()`.\n     *\n     * @param module_ address of module.\n     * @param teardownContract_ address of contract to call to teardown module.\n     * @param data_ data passed to the teardown contract.\n     */\n    function teardownAndDisableModule(address module_, address teardownContract_, bytes calldata data_) external {\n        _authorize();\n\n        _disableModule(module_);\n\n        _call(teardownContract_, 0, data_);\n    }\n\n    /**\n     * @notice Executes a single call from the account.\n     *\n     * @dev Can only be called by a module present in the allowlist.\n     * @dev Emits an event to capture the call executed.\n     *\n     * @param call_ Call to execute from the account.\n     */\n    function executeFromModule(Call calldata call_) external onlyModule {\n        _call(call_);\n\n        emit ExecutedTxFromModule(msg.sender, call_);\n    }\n\n    /**\n     * @notice Executes calls from the account.\n     *\n     * @dev Can only be called by a module present in the allowlist.\n     * @dev Emits an event to capture the call executed.\n     *\n     * @param calls_ Calls to execute from this account.\n     */\n    function executeFromModule(Call[] calldata calls_) external onlyModule {\n        uint256 numCalls = calls_.length;\n\n        for (uint256 i; i < numCalls; i++) {\n            _call(calls_[i]);\n\n            emit ExecutedTxFromModule(msg.sender, calls_[i]);\n        }\n    }\n\n    /**\n     * @notice Returns true if the provided `module` is enabled otherwise false.\n     *\n     * @param module_ address of module.\n     */\n    function isModuleEnabled(address module_) external view returns (bool) {\n        return _getModuleManagerStorage().isModule[module_];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                         INTERNAL/PRIVATE FUNCTIONS                         */\n    /* -------------------------------------------------------------------------- */\n\n    function _enableModule(address module_) internal {\n        _getModuleManagerStorage().isModule[module_] = true;\n\n        emit EnabledModule(module_);\n    }\n\n    function _disableModule(address module_) internal {\n        _getModuleManagerStorage().isModule[module_] = false;\n\n        emit DisabledModule(module_);\n    }\n\n    function _authorize() internal view virtual;\n\n    function _getModuleManagerStorage() internal pure returns (ModuleManagerStorage storage $) {\n        assembly (\"memory-safe\") {\n            $.slot := _MODULE_MANAGER_STORAGE_SLOT\n        }\n    }\n}\n"},"src/utils/MultiSignerAuth.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\nimport { MultiSigner } from \"../signers/MultiSigner.sol\";\nimport { Signer } from \"../signers/Signer.sol\";\n\n/**\n * @title Multi Signer Auth\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n * @notice Auth contract allowing multiple signers, each identified as `Signer` with a specified threshold.\n * @dev Based on Coinbase's Smart Wallet Multi Ownable (https://github.com/coinbase/smart-wallet)\n */\nabstract contract MultiSignerAuth {\n    /* -------------------------------------------------------------------------- */\n    /*                                  CONSTANTS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev Slot for the `MultiSignerStorage` struct in storage.\n     *      Computed from\n     *      keccak256(abi.encode(uint256(keccak256(\"splits.storage.multiSignerAuth\")) - 1)) & ~bytes32(uint256(0xff))\n     *      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n     */\n    bytes32 private constant _MUTLI_SIGNER_AUTH_STORAGE_SLOT =\n        0x3e5431599761dc1a6f375d94085bdcd73bc8fa7c6b3d455d31679f3080214700;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   STRUCT                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /// @custom:storage-location erc7201:splits.storage.multiSignerAuth\n    struct MultiSignerAuthStorage {\n        MultiSigner signers;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Emitted when MultiSigner is initialized.\n     * @param signers Initial set of signers.\n     * @param threshold Initial threshold for the signer set.\n     */\n    event InitializedSigners(Signer[] signers, uint8 threshold);\n\n    /**\n     * @notice Emitted when a new signer is registered.\n     * @param index The index of the signer added.\n     * @param signer The signer added.\n     */\n    event AddSigner(uint256 indexed index, Signer signer);\n\n    /**\n     * @notice Emitted when a signer is removed.\n     * @param index The index of the signer removed.\n     * @param signer The signer removed.\n     */\n    event RemoveSigner(uint256 indexed index, Signer signer);\n\n    /**\n     * @notice Emitted when threshold is updated.\n     * @param threshold The new threshold for the signer set.\n     */\n    event UpdateThreshold(uint8 threshold);\n\n    /* -------------------------------------------------------------------------- */\n    /*                                  MODIFIERS                                 */\n    /* -------------------------------------------------------------------------- */\n\n    modifier onlyAuthorized() {\n        _authorize();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                            PUBLIC VIEW FUNCTIONS                           */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Returns the Signer at the given `index`.\n    function getSigner(uint8 index_) public view returns (Signer memory) {\n        return _getMultiSignerStorage().getSigner(index_);\n    }\n\n    /// @notice Returns the current number of signers.\n    function getSignerCount() public view returns (uint8) {\n        return _getMultiSignerStorage().getSignerCount();\n    }\n\n    /// @notice Returns the threshold.\n    function getThreshold() public view returns (uint8) {\n        return _getMultiSignerStorage().getThreshold();\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Adds a `signer` at the `index`.\n     *\n     * @dev Throws error when a signer is already present at index.\n     * @dev Reverts if Signer is neither EOA or Passkey.\n     *\n     * @param signer_ The Signer to register.\n     * @param index_ The index to register the signer.\n     */\n    function addSigner(Signer calldata signer_, uint8 index_) external onlyAuthorized {\n        _getMultiSignerStorage().addSigner(signer_, index_);\n\n        emit AddSigner(index_, signer_);\n    }\n\n    /**\n     * @notice Removes signer at the given `index`.\n     *\n     * @dev Reverts if 'threshold' is equal to signer count.\n     * @dev Reverts if signer is empty at `index`.\n     *\n     * @param index_ The index of the signer to be removed.\n     */\n    function removeSigner(uint8 index_) external onlyAuthorized {\n        Signer memory signer = _getMultiSignerStorage().removeSigner(index_);\n\n        emit RemoveSigner(index_, signer);\n    }\n\n    /**\n     * @notice Updates threshold of the signer set.\n     *\n     * @dev Reverts if 'threshold' is greater than signer count.\n     * @dev Reverts if 'threshold' is 0.\n     *\n     * @param threshold_ The new signer set threshold.\n     */\n    function updateThreshold(uint8 threshold_) external onlyAuthorized {\n        _getMultiSignerStorage().updateThreshold(threshold_);\n\n        emit UpdateThreshold(threshold_);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function _authorize() internal virtual;\n\n    /// @notice Helper function to get storage reference to the `MultiSignerStorage` struct.\n    function _getMultiSignerStorage() internal view returns (MultiSigner storage) {\n        MultiSignerAuthStorage storage $;\n        assembly (\"memory-safe\") {\n            $.slot := _MUTLI_SIGNER_AUTH_STORAGE_SLOT\n        }\n        return $.signers;\n    }\n\n    /**\n     * @notice Initialize the signers of this contract.\n     *\n     * @dev Intended to be called when contract is first deployed and never again.\n     * @dev Reverts if signer is neither an EOA or a passkey.\n     * @dev Reverts if 'threshold' is less than number of signers.\n     * @dev Reverts if 'threshold' is 0.\n     * @dev Reverts if number of signers is more than 256.\n     *\n     * @param signers_ The initial set of signers.\n     * @param threshold_ The number of signers needed for approval.\n     */\n    function _initializeMultiSignerAuth(Signer[] calldata signers_, uint8 threshold_) internal {\n        _getMultiSignerStorage().initializeSigners(signers_, threshold_);\n\n        emit InitializedSigners(signers_, threshold_);\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/cryptography/MerkleProof.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IAccount.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"},"node_modules/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"node_modules/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"},"node_modules/solady/src/utils/UUPSUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice UUPS proxy mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/UUPSUpgradeable.sol)\n/// @author Modified from OpenZeppelin\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\n///\n/// Note:\n/// - This implementation is intended to be used with ERC1967 proxies.\n/// See: `LibClone.deployERC1967` and related functions.\n/// - This implementation is NOT compatible with legacy OpenZeppelin proxies\n/// which do not store the implementation at `_ERC1967_IMPLEMENTATION_SLOT`.\nabstract contract UUPSUpgradeable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /// @dev The call is from an unauthorized call context.\n    error UnauthorizedCallContext();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         IMMUTABLES                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev For checking if the context is a delegate call.\n    uint256 private immutable __self = uint256(uint160(address(this)));\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when the proxy's implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      UUPS OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to check if `msg.sender` is authorized\n    /// to upgrade the proxy to `newImplementation`, reverting if not.\n    /// ```\n    ///     function _authorizeUpgrade(address) internal override onlyOwner {}\n    /// ```\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /// @dev Returns the storage slot used by the implementation,\n    /// as specified in [ERC1822](https://eips.ethereum.org/EIPS/eip-1822).\n    ///\n    /// Note: The `notDelegated` modifier prevents accidental upgrades to\n    /// an implementation that is a proxy contract.\n    function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }\n\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\n    /// Emits a {Upgraded} event.\n    ///\n    /// Note: Passing in empty `data` skips the delegatecall to `newImplementation`.\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00))\n                {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }\n\n    /// @dev Requires that the execution is performed through a proxy.\n    modifier onlyProxy() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // To enable use cases with an immutable default implementation in the bytecode,\n            // (see: ERC6551Proxy), we don't require that the proxy address must match the\n            // value stored in the implementation slot, which may not be initialized.\n            if eq(s, address()) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Requires that the execution is NOT performed via delegatecall.\n    /// This is the opposite of `onlyProxy`.\n    modifier notDelegated() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(s, address())) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n}\n"},"node_modules/solady/src/utils/SignatureCheckerLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\n///\n/// @dev Note:\n/// - The signature checking functions use the ecrecover precompile (0x1).\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\n///   to copy memory internally.\n/// - Unlike ECDSA signatures, contract signatures are revocable.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary SignatureCheckerLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               SIGNATURE CHECKING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                    let t :=\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            1, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x01, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                        isValid := 1\n                        mstore(0x60, 0) // Restore the zero slot.\n                        mstore(0x40, m) // Restore the free memory pointer.\n                        break\n                    }\n                }\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        add(signature.length, 0x64), // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits of `signer` in case they are dirty.\n            for { signer := shr(96, shl(96, signer)) } signer {} {\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x20, and(v, 0xff)) // `v`.\n                mstore(0x40, r) // `r`.\n                mstore(0x60, s) // `s`.\n                let t :=\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\n                    isValid := 1\n                    mstore(0x60, 0) // Restore the zero slot.\n                    mstore(0x40, m) // Restore the free memory pointer.\n                    break\n                }\n\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                // forgefmt: disable-next-item\n                isValid := and(\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                    eq(mload(d), f),\n                    // Whether the staticcall does not revert.\n                    // This must be placed at the end of the `and` clause,\n                    // as the arguments are evaluated from right to left.\n                    staticcall(\n                        gas(), // Remaining gas.\n                        signer, // The `signer` address.\n                        m, // Offset of calldata in memory.\n                        0xa5, // Length of calldata in memory.\n                        d, // Offset of returndata.\n                        0x20 // Length of returndata to write.\n                    )\n                )\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    add(signature.length, 0x64), // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\n    /// for an ERC1271 `signer` contract.\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            // forgefmt: disable-next-item\n            isValid := and(\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\n                eq(mload(d), f),\n                // Whether the staticcall does not revert.\n                // This must be placed at the end of the `and` clause,\n                // as the arguments are evaluated from right to left.\n                staticcall(\n                    gas(), // Remaining gas.\n                    signer, // The `signer` address.\n                    m, // Offset of calldata in memory.\n                    0xa5, // Length of calldata in memory.\n                    d, // Offset of returndata.\n                    0x20 // Length of returndata to write.\n                )\n            )\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"},"src/library/WebAuthn.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { FCL_ecdsa } from \"FreshCryptoLib/FCL_ecdsa.sol\";\nimport { FCL_Elliptic_ZZ } from \"FreshCryptoLib/FCL_elliptic.sol\";\nimport { Base64 } from \"openzeppelin-contracts/contracts/utils/Base64.sol\";\nimport { LibString } from \"solady/utils/LibString.sol\";\n\n/// @title WebAuthn\n///\n/// @notice A library for verifying WebAuthn Authentication Assertions, built off the work\n///         of Daimo and Coinbase.\n///\n/// @dev Attempts to use the RIP-7212 precompile for signature verification.\n///      If precompile verification fails, it falls back to FreshCryptoLib.\n///\n/// @author Coinbase (https://github.com/base-org/webauthn-sol)\n/// @author Daimo (https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol)\nlibrary WebAuthn {\n    using LibString for string;\n\n    struct WebAuthnAuth {\n        /// @dev The WebAuthn authenticator data.\n        ///      See https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata.\n        bytes authenticatorData;\n        /// @dev The WebAuthn client data JSON.\n        ///      See https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson.\n        string clientDataJSON;\n        /// @dev The index at which \"challenge\":\"...\" occurs in `clientDataJSON`.\n        uint256 challengeIndex;\n        /// @dev The index at which \"type\":\"...\" occurs in `clientDataJSON`.\n        uint256 typeIndex;\n        /// @dev The r value of secp256r1 signature\n        uint256 r;\n        /// @dev The s value of secp256r1 signature\n        uint256 s;\n    }\n\n    /// @dev Bit 0 of the authenticator data struct, corresponding to the \"User Present\" bit.\n    ///      See https://www.w3.org/TR/webauthn-2/#flags.\n    bytes1 private constant _AUTH_DATA_FLAGS_UP = 0x01;\n\n    /// @dev Bit 2 of the authenticator data struct, corresponding to the \"User Verified\" bit.\n    ///      See https://www.w3.org/TR/webauthn-2/#flags.\n    bytes1 private constant _AUTH_DATA_FLAGS_UV = 0x04;\n\n    /// @dev Secp256r1 curve order / 2 used as guard to prevent signature malleability issue.\n    uint256 private constant _P256_N_DIV_2 = FCL_Elliptic_ZZ.n / 2;\n\n    /// @dev The precompiled contract address to use for signature verification in the “secp256r1” elliptic curve.\n    ///      See https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md.\n    address private constant _VERIFIER = address(0x100);\n\n    /// @dev The expected type (hash) in the client data JSON when verifying assertion signatures.\n    ///      See https://www.w3.org/TR/webauthn-2/#dom-collectedclientdata-type\n    // solhint-disable-next-line\n    bytes32 private constant _EXPECTED_TYPE_HASH = keccak256('\"type\":\"webauthn.get\"');\n\n    ///\n    /// @notice Verifies a Webauthn Authentication Assertion as described\n    /// in https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion.\n    ///\n    /// @dev We do not verify all the steps as described in the specification, only ones relevant to our context.\n    ///      Please carefully read through this list before usage.\n    ///\n    ///      Specifically, we do verify the following:\n    ///         - Verify that authenticatorData (which comes from the authenticator, such as iCloud Keychain) indicates\n    ///           a well-formed assertion with the user present bit set. If `requireUV` is set, checks that the\n    /// authenticator\n    ///           enforced user verification. User verification should be required if, and only if,\n    /// options.userVerification\n    ///           is set to required in the request.\n    ///         - Verifies that the client JSON is of type \"webauthn.get\", i.e. the client was responding to a request\n    /// to\n    ///           assert authentication.\n    ///         - Verifies that the client JSON contains the requested challenge.\n    ///         - Verifies that (r, s) constitute a valid signature over both the authenicatorData and client JSON, for\n    /// public\n    ///            key (x, y).\n    ///\n    ///      We make some assumptions about the particular use case of this verifier, so we do NOT verify the following:\n    ///         - Does NOT verify that the origin in the `clientDataJSON` matches the Relying Party's origin: tt is\n    /// considered\n    ///           the authenticator's responsibility to ensure that the user is interacting with the correct RP. This is\n    ///           enforced by most high quality authenticators properly, particularly the iCloud Keychain and Google\n    /// Password\n    ///           Manager were tested.\n    ///         - Does NOT verify That `topOrigin` in `clientDataJSON` is well-formed: We assume it would never be\n    /// present, i.e.\n    ///           the credentials are never used in a cross-origin/iframe context. The website/app set up should\n    /// disallow\n    ///           cross-origin usage of the credentials. This is the default behaviour for created credentials in common\n    /// settings.\n    ///         - Does NOT verify that the `rpIdHash` in `authenticatorData` is the SHA-256 hash of the RP ID expected\n    /// by the Relying\n    ///           Party: this means that we rely on the authenticator to properly enforce credentials to be used only by\n    /// the correct RP.\n    ///           This is generally enforced with features like Apple App Site Association and Google Asset Links. To\n    /// protect from\n    ///           edge cases in which a previously-linked RP ID is removed from the authorised RP IDs, we recommend that\n    /// messages\n    ///           signed by the authenticator include some expiry mechanism.\n    ///         - Does NOT verify the credential backup state: this assumes the credential backup state is NOT used as\n    /// part of Relying\n    ///           Party business logic or policy.\n    ///         - Does NOT verify the values of the client extension outputs: this assumes that the Relying Party does\n    /// not use client\n    ///           extension outputs.\n    ///         - Does NOT verify the signature counter: signature counters are intended to enable risk scoring for the\n    /// Relying Party.\n    ///           This assumes risk scoring is not used as part of Relying Party business logic or policy.\n    ///         - Does NOT verify the attestation object: this assumes that response.attestationObject is NOT present in\n    /// the response,\n    ///           i.e. the RP does not intend to verify an attestation.\n    ///\n    /// @param challenge    The challenge that was provided by the relying party.\n    /// @param requireUV    A boolean indicating whether user verification is required.\n    /// @param webAuthnAuth The `WebAuthnAuth` struct.\n    /// @param x            The x coordinate of the public key.\n    /// @param y            The y coordinate of the public key.\n    ///\n    /// @return `true` if the authentication assertion passed validation, else `false`.\n    function verify(\n        bytes memory challenge,\n        bool requireUV,\n        WebAuthnAuth memory webAuthnAuth,\n        uint256 x,\n        uint256 y\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool deferredResult = true;\n\n        if (webAuthnAuth.s > _P256_N_DIV_2) {\n            // guard against signature malleability\n            deferredResult = false;\n        }\n\n        // 11. Verify that the value of C.type is the string webauthn.get.\n        //     bytes(\"type\":\"webauthn.get\").length = 21\n        if (\n            keccak256(bytes(webAuthnAuth.clientDataJSON.slice(webAuthnAuth.typeIndex, webAuthnAuth.typeIndex + 21)))\n                != _EXPECTED_TYPE_HASH\n        ) {\n            deferredResult = false;\n        }\n\n        // 12. Verify that the value of C.challenge equals the base64url encoding of options.challenge.\n        // solhint-disable-next-line\n        bytes memory expectedChallenge = bytes(string.concat('\"challenge\":\"', Base64.encodeURL(challenge), '\"'));\n        string memory actualChallenge = webAuthnAuth.clientDataJSON.slice(\n            webAuthnAuth.challengeIndex, webAuthnAuth.challengeIndex + expectedChallenge.length\n        );\n        if (keccak256(bytes(actualChallenge)) != keccak256(expectedChallenge)) {\n            deferredResult = false;\n        }\n\n        // Skip 13., 14., 15.\n\n        // 16. Verify that the UP bit of the flags in authData is set.\n        if (webAuthnAuth.authenticatorData[32] & _AUTH_DATA_FLAGS_UP != _AUTH_DATA_FLAGS_UP) {\n            deferredResult = false;\n        }\n\n        // 17. If user verification is required for this assertion, verify that the User Verified bit of the flags in\n        //     authData is set.\n        if (requireUV && (webAuthnAuth.authenticatorData[32] & _AUTH_DATA_FLAGS_UV) != _AUTH_DATA_FLAGS_UV) {\n            deferredResult = false;\n        }\n\n        // skip 18.\n\n        // 19. Let hash be the result of computing a hash over the cData using SHA-256.\n        bytes32 clientDataJSONHash = sha256(bytes(webAuthnAuth.clientDataJSON));\n\n        // 20. Using credentialPublicKey, verify that sig is a valid signature over the binary concatenation of authData\n        //     and hash.\n        bytes32 messageHash = sha256(abi.encodePacked(webAuthnAuth.authenticatorData, clientDataJSONHash));\n        bytes memory args = abi.encode(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y);\n        // try the RIP-7212 precompile address\n        (bool success, bytes memory ret) = _VERIFIER.staticcall(args);\n        // staticcall will not revert if address has no code\n        // check return length\n        // note that even if precompile exists, ret.length is 0 when verification returns false\n        // so an invalid signature will be checked twice: once by the precompile and once by FCL.\n        // Ideally this signature failure is simulated offchain and no one actually pay this gas.\n        bool valid = ret.length > 0;\n        if (success && valid) return abi.decode(ret, (uint256)) == 1 && deferredResult;\n\n        return FCL_ecdsa.ecdsa_verify(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y) && deferredResult;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/cryptography/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"},"node_modules/solady/src/accounts/Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Receiver mixin for ETH and safe-transferred ERC721 and ERC1155 tokens.\n/// @author Solady (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\n///\n/// @dev Note:\n/// - Handles all ERC721 and ERC1155 token safety callbacks.\n/// - Collapses function table gas overhead and code size.\n/// - Utilizes fallback so unknown calldata will pass on.\nabstract contract Receiver {\n    /// @dev For receiving ETH.\n    receive() external payable virtual {}\n\n    /// @dev Fallback function with the `receiverFallback` modifier.\n    fallback() external payable virtual receiverFallback {}\n\n    /// @dev Modifier for the fallback function to handle token callbacks.\n    modifier receiverFallback() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        _;\n    }\n}\n"},"src/utils/Caller.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.23;\n\n/**\n * @title Caller contract\n * @custom:security-contract security@splits.org\n * @author Splits (https://splits.org)\n * @notice Contract that provides basic functionalities to make external calls from a smart contract.\n */\ncontract Caller {\n    /* -------------------------------------------------------------------------- */\n    /*                                   STRUCTS                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Represents a call to execute.\n    struct Call {\n        /// @dev The address to call.\n        address target;\n        /// @dev The value to send when making the call.\n        uint256 value;\n        /// @dev The data of the call.\n        bytes data;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                         INTERNAL/PRIVATE FUNCTIONS                         */\n    /* -------------------------------------------------------------------------- */\n\n    function _call(address target_, uint256 value_, bytes calldata data_) internal {\n        (bool success, bytes memory result) = target_.call{ value: value_ }(data_);\n        if (!success) {\n            assembly (\"memory-safe\") {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    function _call(Call calldata call_) internal {\n        _call(call_.target, call_.value, call_.data);\n    }\n}\n"},"node_modules/FreshCryptoLib/solidity/src/FCL_ecdsa.sol":{"content":"//********************************************************************************************/\n//  ___           _       ___               _         _    _ _\n// | __| _ ___ __| |_    / __|_ _ _  _ _ __| |_ ___  | |  (_) |__\n// | _| '_/ -_|_-< ' \\  | (__| '_| || | '_ \\  _/ _ \\ | |__| | '_ \\\n// |_||_| \\___/__/_||_|  \\___|_|  \\_, | .__/\\__\\___/ |____|_|_.__/\n//                                |__/|_|\n///* Copyright (C) 2022 - Renaud Dubois - This file is part of FCL (Fresh CryptoLib) project\n///* License: This software is licensed under MIT License\n///* This Code may be reused including license and copyright notice.\n///* See LICENSE file at the root folder of the project.\n///* FILE: FCL_ecdsa.sol\n///*\n///*\n///* DESCRIPTION: ecdsa verification implementation\n///*\n//**************************************************************************************/\n//* WARNING: this code SHALL not be used for non prime order curves for security reasons.\n// Code is optimized for a=-3 only curves with prime order, constant like -1, -2 shall be replaced\n// if ever used for other curve than sec256R1\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19 <0.9.0;\n\n\nimport {FCL_Elliptic_ZZ} from \"./FCL_elliptic.sol\";\n\n\n\nlibrary FCL_ecdsa {\n    // Set parameters for curve sec256r1.public\n      //curve order (number of points)\n    uint256 constant n = FCL_Elliptic_ZZ.n;\n  \n    /**\n     * @dev ECDSA verification, given , signature, and public key.\n     */\n\n    /**\n     * @dev ECDSA verification, given , signature, and public key, no calldata version\n     */\n    function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy)  internal view returns (bool){\n\n        if (r == 0 || r >= FCL_Elliptic_ZZ.n || s == 0 || s >= FCL_Elliptic_ZZ.n) {\n            return false;\n        }\n        \n        if (!FCL_Elliptic_ZZ.ecAff_isOnCurve(Qx, Qy)) {\n            return false;\n        }\n\n        uint256 sInv = FCL_Elliptic_ZZ.FCL_nModInv(s);\n\n        uint256 scalar_u = mulmod(uint256(message), sInv, FCL_Elliptic_ZZ.n);\n        uint256 scalar_v = mulmod(r, sInv, FCL_Elliptic_ZZ.n);\n        uint256 x1;\n\n        x1 = FCL_Elliptic_ZZ.ecZZ_mulmuladd_S_asm(Qx, Qy, scalar_u, scalar_v);\n\n        x1= addmod(x1, n-r,n );\n    \n        return x1 == 0;\n    }\n\n    function ec_recover_r1(uint256 h, uint256 v, uint256 r, uint256 s) internal view returns (address)\n    {\n         if (r == 0 || r >= FCL_Elliptic_ZZ.n || s == 0 || s >= FCL_Elliptic_ZZ.n) {\n            return address(0);\n        }\n        uint256 y=FCL_Elliptic_ZZ.ec_Decompress(r, v-27);\n        uint256 rinv=FCL_Elliptic_ZZ.FCL_nModInv(r);\n        uint256 u1=mulmod(FCL_Elliptic_ZZ.n-addmod(0,h,FCL_Elliptic_ZZ.n), rinv,FCL_Elliptic_ZZ.n);//-hr^-1\n        uint256 u2=mulmod(s, rinv,FCL_Elliptic_ZZ.n);//sr^-1\n\n        uint256 Qx;\n        uint256 Qy;\n        (Qx,Qy)=FCL_Elliptic_ZZ.ecZZ_mulmuladd(r,y, u1, u2);\n\n        return address(uint160(uint256(keccak256(abi.encodePacked(Qx, Qy)))));\n    }\n\n    function ecdsa_precomputed_verify(bytes32 message, uint256 r, uint256 s, address Shamir8)\n        internal view\n        returns (bool)\n    {\n       \n        if (r == 0 || r >= n || s == 0 || s >= n) {\n            return false;\n        }\n        /* Q is pushed via the contract at address Shamir8 assumed to be correct\n        if (!isOnCurve(Q[0], Q[1])) {\n            return false;\n        }*/\n\n        uint256 sInv = FCL_Elliptic_ZZ.FCL_nModInv(s);\n\n        uint256 X;\n\n        //Shamir 8 dimensions\n        X = FCL_Elliptic_ZZ.ecZZ_mulmuladd_S8_extcode(mulmod(uint256(message), sInv, n), mulmod(r, sInv, n), Shamir8);\n\n        X= addmod(X, n-r,n );\n\n        return X == 0;\n    } //end  ecdsa_precomputed_verify()\n\n     function ecdsa_precomputed_verify(bytes32 message, uint256[2] calldata rs, address Shamir8)\n        internal view\n        returns (bool)\n    {\n        uint256 r = rs[0];\n        uint256 s = rs[1];\n        if (r == 0 || r >= n || s == 0 || s >= n) {\n            return false;\n        }\n        /* Q is pushed via the contract at address Shamir8 assumed to be correct\n        if (!isOnCurve(Q[0], Q[1])) {\n            return false;\n        }*/\n\n        uint256 sInv = FCL_Elliptic_ZZ.FCL_nModInv(s);\n\n        uint256 X;\n\n        //Shamir 8 dimensions\n        X = FCL_Elliptic_ZZ.ecZZ_mulmuladd_S8_extcode(mulmod(uint256(message), sInv, n), mulmod(r, sInv, n), Shamir8);\n\n        X= addmod(X, n-r,n );\n\n        return X == 0;\n    } //end  ecdsa_precomputed_verify()\n\n}\n"},"node_modules/FreshCryptoLib/solidity/src/FCL_elliptic.sol":{"content":"//********************************************************************************************/\n//  ___           _       ___               _         _    _ _\n// | __| _ ___ __| |_    / __|_ _ _  _ _ __| |_ ___  | |  (_) |__\n// | _| '_/ -_|_-< ' \\  | (__| '_| || | '_ \\  _/ _ \\ | |__| | '_ \\\n// |_||_| \\___/__/_||_|  \\___|_|  \\_, | .__/\\__\\___/ |____|_|_.__/\n//                                |__/|_|\n///* Copyright (C) 2022 - Renaud Dubois - This file is part of FCL (Fresh CryptoLib) project\n///* License: This software is licensed under MIT License\n///* This Code may be reused including license and copyright notice.\n///* See LICENSE file at the root folder of the project.\n///* FILE: FCL_elliptic.sol\n///*\n///*\n///* DESCRIPTION: modified XYZZ system coordinates for EVM elliptic point multiplication\n///*  optimization\n///*\n//**************************************************************************************/\n//* WARNING: this code SHALL not be used for non prime order curves for security reasons.\n// Code is optimized for a=-3 only curves with prime order, constant like -1, -2 shall be replaced\n// if ever used for other curve than sec256R1\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19 <0.9.0;\n\nlibrary FCL_Elliptic_ZZ {\n    // Set parameters for curve sec256r1.\n\n    // address of the ModExp precompiled contract (Arbitrary-precision exponentiation under modulo)\n    address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005;\n    //curve prime field modulus\n    uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n    //short weierstrass first coefficient\n    uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    //short weierstrass second coefficient\n    uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    //generating point affine coordinates\n    uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    //curve order (number of points)\n    uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n    /* -2 mod p constant, used to speed up inversion and doubling (avoid negation)*/\n    uint256 constant minus_2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD;\n    /* -2 mod n constant, used to speed up inversion*/\n    uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F;\n\n    uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    //P+1 div 4\n    uint256 constant pp1div4=0x3fffffffc0000000400000000000000000000000400000000000000000000000;\n    //arbitrary constant to express no quadratic residuosity\n    uint256 constant _NOTSQUARE=0xFFFFFFFF00000002000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 constant _NOTONCURVE=0xFFFFFFFF00000003000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n\n    /**\n     * /* inversion mod n via a^(n-2), use of precompiled using little Fermat theorem\n     */\n    function FCL_nModInv(uint256 u) internal view returns (uint256 result) {\n        assembly {\n            let pointer := mload(0x40)\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\n            mstore(pointer, 0x20)\n            mstore(add(pointer, 0x20), 0x20)\n            mstore(add(pointer, 0x40), 0x20)\n            // Define variables base, exponent and modulus\n            mstore(add(pointer, 0x60), u)\n            mstore(add(pointer, 0x80), minus_2modn)\n            mstore(add(pointer, 0xa0), n)\n\n            // Call the precompiled contract 0x05 = ModExp\n            if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n            result := mload(pointer)\n        }\n    }\n    /**\n     * /* @dev inversion mod nusing little Fermat theorem via a^(n-2), use of precompiled\n     */\n\n    function FCL_pModInv(uint256 u) internal view returns (uint256 result) {\n        assembly {\n            let pointer := mload(0x40)\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\n            mstore(pointer, 0x20)\n            mstore(add(pointer, 0x20), 0x20)\n            mstore(add(pointer, 0x40), 0x20)\n            // Define variables base, exponent and modulus\n            mstore(add(pointer, 0x60), u)\n            mstore(add(pointer, 0x80), minus_2)\n            mstore(add(pointer, 0xa0), p)\n\n            // Call the precompiled contract 0x05 = ModExp\n            if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n            result := mload(pointer)\n        }\n    }\n\n    //Coron projective shuffling, take as input alpha as blinding factor\n   function ecZZ_Coronize(uint256 alpha, uint256 x, uint256 y,  uint256 zz, uint256 zzz) internal pure  returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\n   {\n       \n        uint256 alpha2=mulmod(alpha,alpha,p);\n       \n        x3=mulmod(alpha2, x,p); //alpha^-2.x\n        y3=mulmod(mulmod(alpha, alpha2,p), y,p);\n\n        zz3=mulmod(zz,alpha2,p);//alpha^2 zz\n        zzz3=mulmod(zzz,mulmod(alpha, alpha2,p),p);//alpha^3 zzz\n        \n        return (x3, y3, zz3, zzz3);\n   }\n\n\n function ecZZ_Add(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2, uint256 zz2, uint256 zzz2) internal pure  returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\n  {\n    uint256 u1=mulmod(x1,zz2,p); // U1 = X1*ZZ2\n    uint256 u2=mulmod(x2, zz1,p);               //  U2 = X2*ZZ1\n    u2=addmod(u2, p-u1, p);//  P = U2-U1\n    x1=mulmod(u2, u2, p);//PP\n    x2=mulmod(x1, u2, p);//PPP\n    \n    zz3=mulmod(x1, mulmod(zz1, zz2, p),p);//ZZ3 = ZZ1*ZZ2*PP  \n    zzz3=mulmod(zzz1, mulmod(zzz2, x2, p),p);//ZZZ3 = ZZZ1*ZZZ2*PPP\n\n    zz1=mulmod(y1, zzz2,p);  // S1 = Y1*ZZZ2\n    zz2=mulmod(y2, zzz1, p);    // S2 = Y2*ZZZ1 \n    zz2=addmod(zz2, p-zz1, p);//R = S2-S1\n    zzz1=mulmod(u1, x1,p); //Q = U1*PP\n    x3= addmod(addmod(mulmod(zz2, zz2, p), p-x2,p), mulmod(minus_2, zzz1,p),p); //X3 = R2-PPP-2*Q\n    y3=addmod( mulmod(zz2, addmod(zzz1, p-x3, p),p), p-mulmod(zz1, x2, p),p);//R*(Q-X3)-S1*PPP\n\n    return (x3, y3, zz3, zzz3);\n  }\n\n/// @notice Calculate one modular square root of a given integer. Assume that p=3 mod 4.\n/// @dev Uses the ModExp precompiled contract at address 0x05 for fast computation using little Fermat theorem\n/// @param self The integer of which to find the modular inverse\n/// @return result The modular inverse of the input integer. If the modular inverse doesn't exist, it revert the tx\n\nfunction SqrtMod(uint256 self) internal view returns (uint256 result){\n assembly (\"memory-safe\") {\n        // load the free memory pointer value\n        let pointer := mload(0x40)\n\n        // Define length of base (Bsize)\n        mstore(pointer, 0x20)\n        // Define the exponent size (Esize)\n        mstore(add(pointer, 0x20), 0x20)\n        // Define the modulus size (Msize)\n        mstore(add(pointer, 0x40), 0x20)\n        // Define variables base (B)\n        mstore(add(pointer, 0x60), self)\n        // Define the exponent (E)\n        mstore(add(pointer, 0x80), pp1div4)\n        // We save the point of the last argument, it will be override by the result\n        // of the precompile call in order to avoid paying for the memory expansion properly\n        let _result := add(pointer, 0xa0)\n        // Define the modulus (M)\n        mstore(_result, p)\n\n        // Call the precompiled ModExp (0x05) https://www.evm.codes/precompiled#0x05\n        if iszero(\n            staticcall(\n                not(0), // amount of gas to send\n                MODEXP_PRECOMPILE, // target\n                pointer, // argsOffset\n                0xc0, // argsSize (6 * 32 bytes)\n                _result, // retOffset (we override M to avoid paying for the memory expansion)\n                0x20 // retSize (32 bytes)\n            )\n        ) { revert(0, 0) }\n\n  result := mload(_result)\n//  result :=addmod(result,0,p)\n }\n   if(mulmod(result,result,p)!=self){\n     result=_NOTSQUARE;\n   }\n  \n   return result;\n}\n    /**\n     * /* @dev Convert from affine rep to XYZZ rep\n     */\n    function ecAff_SetZZ(uint256 x0, uint256 y0) internal pure returns (uint256[4] memory P) {\n        unchecked {\n            P[2] = 1; //ZZ\n            P[3] = 1; //ZZZ\n            P[0] = x0;\n            P[1] = y0;\n        }\n    }\n\n    function ec_Decompress(uint256 x, uint256 parity) internal view returns(uint256 y){ \n\n        uint256 y2=mulmod(x,mulmod(x,x,p),p);//x3\n        y2=addmod(b,addmod(y2,mulmod(x,a,p),p),p);//x3+ax+b\n\n        y=SqrtMod(y2);\n        if(y==_NOTSQUARE){\n           return _NOTONCURVE;\n        }\n        if((y&1)!=(parity&1)){\n            y=p-y;\n        }\n    }\n\n    /**\n     * /* @dev Convert from XYZZ rep to affine rep\n     */\n    /*    https://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz-3.html#addition-add-2008-s*/\n    function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) internal view returns (uint256 x1, uint256 y1) {\n        uint256 zzzInv = FCL_pModInv(zzz); //1/zzz\n        y1 = mulmod(y, zzzInv, p); //Y/zzz\n        uint256 _b = mulmod(zz, zzzInv, p); //1/z\n        zzzInv = mulmod(_b, _b, p); //1/zz\n        x1 = mulmod(x, zzzInv, p); //X/zz\n    }\n\n    /**\n     * /* @dev Sutherland2008 doubling\n     */\n    /* The \"dbl-2008-s-1\" doubling formulas */\n\n    function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz)\n        internal\n        pure\n        returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n    {\n        unchecked {\n            assembly {\n                P0 := mulmod(2, y, p) //U = 2*Y1\n                P2 := mulmod(P0, P0, p) // V=U^2\n                P3 := mulmod(x, P2, p) // S = X1*V\n                P1 := mulmod(P0, P2, p) // W=UV\n                P2 := mulmod(P2, zz, p) //zz3=V*ZZ1\n                zz := mulmod(3, mulmod(addmod(x, sub(p, zz), p), addmod(x, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n                P0 := addmod(mulmod(zz, zz, p), mulmod(minus_2, P3, p), p) //X3=M^2-2S\n                x := mulmod(zz, addmod(P3, sub(p, P0), p), p) //M(S-X3)\n                P3 := mulmod(P1, zzz, p) //zzz3=W*zzz1\n                P1 := addmod(x, sub(p, mulmod(P1, y, p)), p) //Y3= M(S-X3)-W*Y1\n            }\n        }\n        return (P0, P1, P2, P3);\n    }\n\n    /**\n     * @dev Sutherland2008 add a ZZ point with a normalized point and greedy formulae\n     * warning: assume that P1(x1,y1)!=P2(x2,y2), true in multiplication loop with prime order (cofactor 1)\n     */\n\n    function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2)\n        internal\n        pure\n        returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n    {\n        unchecked {\n            if (y1 == 0) {\n                return (x2, y2, 1, 1);\n            }\n\n            assembly {\n                y1 := sub(p, y1)\n                y2 := addmod(mulmod(y2, zzz1, p), y1, p)\n                x2 := addmod(mulmod(x2, zz1, p), sub(p, x1), p)\n                P0 := mulmod(x2, x2, p) //PP = P^2\n                P1 := mulmod(P0, x2, p) //PPP = P*PP\n                P2 := mulmod(zz1, P0, p) ////ZZ3 = ZZ1*PP\n                P3 := mulmod(zzz1, P1, p) ////ZZZ3 = ZZZ1*PPP\n                zz1 := mulmod(x1, P0, p) //Q = X1*PP\n                P0 := addmod(addmod(mulmod(y2, y2, p), sub(p, P1), p), mulmod(minus_2, zz1, p), p) //R^2-PPP-2*Q\n                P1 := addmod(mulmod(addmod(zz1, sub(p, P0), p), y2, p), mulmod(y1, P1, p), p) //R*(Q-X3)\n            }\n            //end assembly\n        } //end unchecked\n        return (P0, P1, P2, P3);\n    }\n\n    /**\n     * @dev Return the zero curve in XYZZ coordinates.\n     */\n    function ecZZ_SetZero() internal pure returns (uint256 x, uint256 y, uint256 zz, uint256 zzz) {\n        return (0, 0, 0, 0);\n    }\n    /**\n     * @dev Check if point is the neutral of the curve\n     */\n\n    // uint256 x0, uint256 y0, uint256 zz0, uint256 zzz0\n    function ecZZ_IsZero(uint256, uint256 y0, uint256, uint256) internal pure returns (bool) {\n        return y0 == 0;\n    }\n    /**\n     * @dev Return the zero curve in affine coordinates. Compatible with the double formulae (no special case)\n     */\n\n    function ecAff_SetZero() internal pure returns (uint256 x, uint256 y) {\n        return (0, 0);\n    }\n\n    /**\n     * @dev Check if the curve is the zero curve in affine rep.\n     */\n    // uint256 x, uint256 y)\n    function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) {\n        return (y == 0);\n    }\n\n    /**\n     * @dev Check if a point in affine coordinates is on the curve (reject Neutral that is indeed on the curve).\n     */\n    function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\n        if (x >= p || y >= p || ((x == 0) && (y == 0))) {\n            return false;\n        }\n        unchecked {\n            uint256 LHS = mulmod(y, y, p); // y^2\n            uint256 RHS = addmod(mulmod(mulmod(x, x, p), x, p), mulmod(x, a, p), p); // x^3+ax\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\n\n            return LHS == RHS;\n        }\n    }\n\n    /**\n     * @dev Add two elliptic curve points in affine coordinates. Deal with P=Q\n     */\n\n    function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) {\n        uint256 zz0;\n        uint256 zzz0;\n\n        if (ecAff_IsZero(x0, y0)) return (x1, y1);\n        if (ecAff_IsZero(x1, y1)) return (x0, y0);\n        if((x0==x1)&&(y0==y1)) {\n            (x0, y0, zz0, zzz0) = ecZZ_Dbl(x0, y0,1,1);\n        }\n        else{\n            (x0, y0, zz0, zzz0) = ecZZ_AddN(x0, y0, 1, 1, x1, y1);\n        }\n\n        return ecZZ_SetAff(x0, y0, zz0, zzz0);\n    }\n\n    /**\n     * @dev Computation of uG+vQ using Strauss-Shamir's trick, G basepoint, Q public key\n     *       Returns only x for ECDSA use            \n     *      */\n    function ecZZ_mulmuladd_S_asm(\n        uint256 Q0,\n        uint256 Q1, //affine rep for input point Q\n        uint256 scalar_u,\n        uint256 scalar_v\n    ) internal view returns (uint256 X) {\n        uint256 zz;\n        uint256 zzz;\n        uint256 Y;\n        uint256 index = 255;\n        uint256 H0;\n        uint256 H1;\n\n        unchecked {\n            if (scalar_u == 0 && scalar_v == 0) return 0;\n\n            (H0, H1) = ecAff_add(gx, gy, Q0, Q1); \n            if((H0==0)&&(H1==0))//handling Q=-G\n            {\n                scalar_u=addmod(scalar_u, n-scalar_v, n);\n                scalar_v=0;\n                if (scalar_u == 0 && scalar_v == 0) return 0;\n            }\n            assembly {\n                for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\n                    index := sub(index, 1)\n                    T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n                } {}\n                zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n\n                if eq(zz, 1) {\n                    X := gx\n                    Y := gy\n                }\n                if eq(zz, 2) {\n                    X := Q0\n                    Y := Q1\n                }\n                if eq(zz, 3) {\n                    X := H0\n                    Y := H1\n                }\n\n                index := sub(index, 1)\n                zz := 1\n                zzz := 1\n\n                for {} gt(minus_1, index) { index := sub(index, 1) } {\n                    // inlined EcZZ_Dbl\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n                    let T2 := mulmod(T1, T1, p) // V=U^2\n                    let T3 := mulmod(X, T2, p) // S = X1*V\n                    T1 := mulmod(T1, T2, p) // W=UV\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n\n                    {\n                        //value of dibit\n                        T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n\n                        if iszero(T4) {\n                            Y := sub(p, Y) //restore the -Y inversion\n                            continue\n                        } // if T4!=0\n\n                        if eq(T4, 1) {\n                            T1 := gx\n                            T2 := gy\n                        }\n                        if eq(T4, 2) {\n                            T1 := Q0\n                            T2 := Q1\n                        }\n                        if eq(T4, 3) {\n                            T1 := H0\n                            T2 := H1\n                        }\n                        if iszero(zz) {\n                            X := T1\n                            Y := T2\n                            zz := 1\n                            zzz := 1\n                            continue\n                        }\n                        // inlined EcZZ_AddN\n\n                        //T3:=sub(p, Y)\n                        //T3:=Y\n                        let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\n                        T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\n\n                        //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\n                        //todo : construct edge vector case\n                        if iszero(y2) {\n                            if iszero(T2) {\n                                T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n                                T2 := mulmod(T1, T1, p) // V=U^2\n                                T3 := mulmod(X, T2, p) // S = X1*V\n\n                                T1 := mulmod(T1, T2, p) // W=UV\n                                y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n                                T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n\n                                zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n\n                                continue\n                            }\n                        }\n\n                        T4 := mulmod(T2, T2, p) //PP\n                        let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\n                        zz := mulmod(zz, T4, p)\n                        zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n                        let TT2 := mulmod(X, T4, p)\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\n                        Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n\n                        X := T4\n                    }\n                } //end loop\n                let T := mload(0x40)\n                mstore(add(T, 0x60), zz)\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\n                mstore(T, 0x20)\n                mstore(add(T, 0x20), 0x20)\n                mstore(add(T, 0x40), 0x20)\n                // Define variables base, exponent and modulus\n                //mstore(add(pointer, 0x60), u)\n                mstore(add(T, 0x80), minus_2)\n                mstore(add(T, 0xa0), p)\n\n                // Call the precompiled contract 0x05 = ModExp\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n\n                //Y:=mulmod(Y,zzz,p)//Y/zzz\n                //zz :=mulmod(zz, mload(T),p) //1/z\n                //zz:= mulmod(zz,zz,p) //1/zz\n                X := mulmod(X, mload(T), p) //X/zz\n            } //end assembly\n        } //end unchecked\n\n        return X;\n    }\n\n\n    /**\n     * @dev Computation of uG+vQ using Strauss-Shamir's trick, G basepoint, Q public key\n     *       Returns affine representation of point (normalized)       \n     *      */\n    function ecZZ_mulmuladd(\n        uint256 Q0,\n        uint256 Q1, //affine rep for input point Q\n        uint256 scalar_u,\n        uint256 scalar_v\n    ) internal view returns (uint256 X, uint256 Y) {\n        uint256 zz;\n        uint256 zzz;\n        uint256 index = 255;\n        uint256[6] memory T;\n        uint256[2] memory H;\n \n        unchecked {\n            if (scalar_u == 0 && scalar_v == 0) return (0,0);\n\n            (H[0], H[1]) = ecAff_add(gx, gy, Q0, Q1); //will not work if Q=P, obvious forbidden private key\n\n            assembly {\n                for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\n                    index := sub(index, 1)\n                    T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n                } {}\n                zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n\n                if eq(zz, 1) {\n                    X := gx\n                    Y := gy\n                }\n                if eq(zz, 2) {\n                    X := Q0\n                    Y := Q1\n                }\n                if eq(zz, 3) {\n                    Y := mload(add(H,32))\n                    X := mload(H)\n                }\n\n                index := sub(index, 1)\n                zz := 1\n                zzz := 1\n\n                for {} gt(minus_1, index) { index := sub(index, 1) } {\n                    // inlined EcZZ_Dbl\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n                    let T2 := mulmod(T1, T1, p) // V=U^2\n                    let T3 := mulmod(X, T2, p) // S = X1*V\n                    T1 := mulmod(T1, T2, p) // W=UV\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n\n                    {\n                        //value of dibit\n                        T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n\n                        if iszero(T4) {\n                            Y := sub(p, Y) //restore the -Y inversion\n                            continue\n                        } // if T4!=0\n\n                        if eq(T4, 1) {\n                            T1 := gx\n                            T2 := gy\n                        }\n                        if eq(T4, 2) {\n                            T1 := Q0\n                            T2 := Q1\n                        }\n                        if eq(T4, 3) {\n                            T1 := mload(H)\n                            T2 := mload(add(H,32))\n                        }\n                        if iszero(zz) {\n                            X := T1\n                            Y := T2\n                            zz := 1\n                            zzz := 1\n                            continue\n                        }\n                        // inlined EcZZ_AddN\n\n                        //T3:=sub(p, Y)\n                        //T3:=Y\n                        let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\n                        T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\n\n                        //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\n                        //todo : construct edge vector case\n                        if iszero(y2) {\n                            if iszero(T2) {\n                                T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n                                T2 := mulmod(T1, T1, p) // V=U^2\n                                T3 := mulmod(X, T2, p) // S = X1*V\n\n                                T1 := mulmod(T1, T2, p) // W=UV\n                                y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n                                T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n\n                                zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n\n                                continue\n                            }\n                        }\n\n                        T4 := mulmod(T2, T2, p) //PP\n                        let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\n                        zz := mulmod(zz, T4, p)\n                        zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n                        let TT2 := mulmod(X, T4, p)\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\n                        Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n\n                        X := T4\n                    }\n                } //end loop\n                mstore(add(T, 0x60), zzz)\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\n                mstore(T, 0x20)\n                mstore(add(T, 0x20), 0x20)\n                mstore(add(T, 0x40), 0x20)\n                // Define variables base, exponent and modulus\n                //mstore(add(pointer, 0x60), u)\n                mstore(add(T, 0x80), minus_2)\n                mstore(add(T, 0xa0), p)\n\n                // Call the precompiled contract 0x05 = ModExp\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n\n                Y:=mulmod(Y,mload(T),p)//Y/zzz\n                zz :=mulmod(zz, mload(T),p) //1/z\n                zz:= mulmod(zz,zz,p) //1/zz\n                X := mulmod(X, zz, p) //X/zz\n            } //end assembly\n        } //end unchecked\n\n        return (X,Y);\n    }\n\n    //8 dimensions Shamir's trick, using precomputations stored in Shamir8,  stored as Bytecode of an external\n    //contract at given address dataPointer\n    //(thx to Lakhdar https://github.com/Kelvyne for EVM storage explanations and tricks)\n    // the external tool to generate tables from public key is in the /sage directory\n    function ecZZ_mulmuladd_S8_extcode(uint256 scalar_u, uint256 scalar_v, address dataPointer)\n        internal view\n        returns (uint256 X /*, uint Y*/ )\n    {\n        unchecked {\n            uint256 zz; // third and  coordinates of the point\n\n            uint256[6] memory T;\n            zz = 256; //start index\n\n            while (T[0] == 0) {\n                zz = zz - 1;\n                //tbd case of msb octobit is null\n                T[0] = 64\n                    * (\n                        128 * ((scalar_v >> zz) & 1) + 64 * ((scalar_v >> (zz - 64)) & 1)\n                            + 32 * ((scalar_v >> (zz - 128)) & 1) + 16 * ((scalar_v >> (zz - 192)) & 1)\n                            + 8 * ((scalar_u >> zz) & 1) + 4 * ((scalar_u >> (zz - 64)) & 1)\n                            + 2 * ((scalar_u >> (zz - 128)) & 1) + ((scalar_u >> (zz - 192)) & 1)\n                    );\n            }\n            assembly {\n                extcodecopy(dataPointer, T, mload(T), 64)\n                let index := sub(zz, 1)\n                X := mload(T)\n                let Y := mload(add(T, 32))\n                let zzz := 1\n                zz := 1\n\n                //loop over 1/4 of scalars thx to Shamir's trick over 8 points\n                for {} gt(index, 191) { index := add(index, 191) } {\n                    //inline Double\n                    {\n                        let TT1 := mulmod(2, Y, p) //U = 2*Y1, y free\n                        let T2 := mulmod(TT1, TT1, p) // V=U^2\n                        let T3 := mulmod(X, T2, p) // S = X1*V\n                        let T1 := mulmod(TT1, T2, p) // W=UV\n                        let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n                        zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n                        zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n\n                        X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n                        //T2:=mulmod(T4,addmod(T3, sub(p, X),p),p)//M(S-X3)\n                        let T5 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n\n                        //Y:= addmod(T2, sub(p, mulmod(T1, Y ,p)),p  )//Y3= M(S-X3)-W*Y1\n                        Y := addmod(mulmod(T1, Y, p), T5, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n\n                        /* compute element to access in precomputed table */\n                    }\n                    {\n                        let T4 := add(shl(13, and(shr(index, scalar_v), 1)), shl(9, and(shr(index, scalar_u), 1)))\n                        let index2 := sub(index, 64)\n                        let T3 :=\n                            add(T4, add(shl(12, and(shr(index2, scalar_v), 1)), shl(8, and(shr(index2, scalar_u), 1))))\n                        let index3 := sub(index2, 64)\n                        let T2 :=\n                            add(T3, add(shl(11, and(shr(index3, scalar_v), 1)), shl(7, and(shr(index3, scalar_u), 1))))\n                        index := sub(index3, 64)\n                        let T1 :=\n                            add(T2, add(shl(10, and(shr(index, scalar_v), 1)), shl(6, and(shr(index, scalar_u), 1))))\n\n                        //tbd: check validity of formulae with (0,1) to remove conditional jump\n                        if iszero(T1) {\n                            Y := sub(p, Y)\n\n                            continue\n                        }\n                        extcodecopy(dataPointer, T, T1, 64)\n                    }\n\n                    {\n                        /* Access to precomputed table using extcodecopy hack */\n\n                        // inlined EcZZ_AddN\n                        if iszero(zz) {\n                            X := mload(T)\n                            Y := mload(add(T, 32))\n                            zz := 1\n                            zzz := 1\n\n                            continue\n                        }\n\n                        let y2 := addmod(mulmod(mload(add(T, 32)), zzz, p), Y, p)\n                        let T2 := addmod(mulmod(mload(T), zz, p), sub(p, X), p)\n\n                        //special case ecAdd(P,P)=EcDbl\n                        if iszero(y2) {\n                            if iszero(T2) {\n                                let T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n                                T2 := mulmod(T1, T1, p) // V=U^2\n                                let T3 := mulmod(X, T2, p) // S = X1*V\n\n                                T1 := mulmod(T1, T2, p) // W=UV\n                                y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n                                let T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n\n                                zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n\n                                continue\n                            }\n                        }\n\n                        let T4 := mulmod(T2, T2, p)\n                        let T1 := mulmod(T4, T2, p) //\n                        zz := mulmod(zz, T4, p)\n                        //zzz3=V*ZZ1\n                        zzz := mulmod(zzz, T1, p) // W=UV/\n                        let zz1 := mulmod(X, T4, p)\n                        X := addmod(addmod(mulmod(y2, y2, p), sub(p, T1), p), mulmod(minus_2, zz1, p), p)\n                        Y := addmod(mulmod(addmod(zz1, sub(p, X), p), y2, p), mulmod(Y, T1, p), p)\n                    }\n                } //end loop\n                mstore(add(T, 0x60), zz)\n\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\n                mstore(T, 0x20)\n                mstore(add(T, 0x20), 0x20)\n                mstore(add(T, 0x40), 0x20)\n                // Define variables base, exponent and modulus\n                //mstore(add(pointer, 0x60), u)\n                mstore(add(T, 0x80), minus_2)\n                mstore(add(T, 0xa0), p)\n\n                // Call the precompiled contract 0x05 = ModExp\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n\n                zz := mload(T)\n                X := mulmod(X, zz, p) //X/zz\n            }\n        } //end unchecked\n    }\n\n   \n\n    // improving the extcodecopy trick : append array at end of contract\n    function ecZZ_mulmuladd_S8_hackmem(uint256 scalar_u, uint256 scalar_v, uint256 dataPointer)\n        internal view\n        returns (uint256 X /*, uint Y*/ )\n    {\n        uint256 zz; // third and  coordinates of the point\n\n        uint256[6] memory T;\n        zz = 256; //start index\n\n        unchecked {\n            while (T[0] == 0) {\n                zz = zz - 1;\n                //tbd case of msb octobit is null\n                T[0] = 64\n                    * (\n                        128 * ((scalar_v >> zz) & 1) + 64 * ((scalar_v >> (zz - 64)) & 1)\n                            + 32 * ((scalar_v >> (zz - 128)) & 1) + 16 * ((scalar_v >> (zz - 192)) & 1)\n                            + 8 * ((scalar_u >> zz) & 1) + 4 * ((scalar_u >> (zz - 64)) & 1)\n                            + 2 * ((scalar_u >> (zz - 128)) & 1) + ((scalar_u >> (zz - 192)) & 1)\n                    );\n            }\n            assembly {\n                codecopy(T, add(mload(T), dataPointer), 64)\n                X := mload(T)\n                let Y := mload(add(T, 32))\n                let zzz := 1\n                zz := 1\n\n                //loop over 1/4 of scalars thx to Shamir's trick over 8 points\n                for { let index := 254 } gt(index, 191) { index := add(index, 191) } {\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n                    let T2 := mulmod(T1, T1, p) // V=U^2\n                    let T3 := mulmod(X, T2, p) // S = X1*V\n                    T1 := mulmod(T1, T2, p) // W=UV\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n                    //T2:=mulmod(T4,addmod(T3, sub(p, X),p),p)//M(S-X3)\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n\n                    //Y:= addmod(T2, sub(p, mulmod(T1, Y ,p)),p  )//Y3= M(S-X3)-W*Y1\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n\n                    /* compute element to access in precomputed table */\n                    T4 := add(shl(13, and(shr(index, scalar_v), 1)), shl(9, and(shr(index, scalar_u), 1)))\n                    index := sub(index, 64)\n                    T4 := add(T4, add(shl(12, and(shr(index, scalar_v), 1)), shl(8, and(shr(index, scalar_u), 1))))\n                    index := sub(index, 64)\n                    T4 := add(T4, add(shl(11, and(shr(index, scalar_v), 1)), shl(7, and(shr(index, scalar_u), 1))))\n                    index := sub(index, 64)\n                    T4 := add(T4, add(shl(10, and(shr(index, scalar_v), 1)), shl(6, and(shr(index, scalar_u), 1))))\n                    //index:=add(index,192), restore index, interleaved with loop\n\n                    //tbd: check validity of formulae with (0,1) to remove conditional jump\n                    if iszero(T4) {\n                        Y := sub(p, Y)\n\n                        continue\n                    }\n                    {\n                        /* Access to precomputed table using extcodecopy hack */\n                        codecopy(T, add(T4, dataPointer), 64)\n\n                        // inlined EcZZ_AddN\n\n                        let y2 := addmod(mulmod(mload(add(T, 32)), zzz, p), Y, p)\n                        T2 := addmod(mulmod(mload(T), zz, p), sub(p, X), p)\n                        T4 := mulmod(T2, T2, p)\n                        T1 := mulmod(T4, T2, p)\n                        T2 := mulmod(zz, T4, p) // W=UV\n                        zzz := mulmod(zzz, T1, p) //zz3=V*ZZ1\n                        let zz1 := mulmod(X, T4, p)\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, T1), p), mulmod(minus_2, zz1, p), p)\n                        Y := addmod(mulmod(addmod(zz1, sub(p, T4), p), y2, p), mulmod(Y, T1, p), p)\n                        zz := T2\n                        X := T4\n                    }\n                } //end loop\n                mstore(add(T, 0x60), zz)\n\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\n                mstore(T, 0x20)\n                mstore(add(T, 0x20), 0x20)\n                mstore(add(T, 0x40), 0x20)\n                // Define variables base, exponent and modulus\n                //mstore(add(pointer, 0x60), u)\n                mstore(add(T, 0x80), minus_2)\n                mstore(add(T, 0xa0), p)\n\n                // Call the precompiled contract 0x05 = ModExp\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n\n                zz := mload(T)\n                X := mulmod(X, zz, p) //X/zz\n            }\n        } //end unchecked\n    }\n\n\n    /**\n     * @dev ECDSA verification using a precomputed table of multiples of P and Q stored in contract at address Shamir8\n     *     generation of contract bytecode for precomputations is done using sagemath code\n     *     (see sage directory, WebAuthn_precompute.sage)\n     */\n\n    /**\n     * @dev ECDSA verification using a precomputed table of multiples of P and Q appended at end of contract at address endcontract\n     *     generation of contract bytecode for precomputations is done using sagemath code\n     *     (see sage directory, WebAuthn_precompute.sage)\n     */\n\n    function ecdsa_precomputed_hackmem(bytes32 message, uint256[2] calldata rs, uint256 endcontract)\n        internal view\n        returns (bool)\n    {\n        uint256 r = rs[0];\n        uint256 s = rs[1];\n        if (r == 0 || r >= n || s == 0 || s >= n) {\n            return false;\n        }\n        /* Q is pushed via bytecode assumed to be correct\n        if (!isOnCurve(Q[0], Q[1])) {\n            return false;\n        }*/\n\n        uint256 sInv = FCL_nModInv(s);\n        uint256 X;\n\n        //Shamir 8 dimensions\n        X = ecZZ_mulmuladd_S8_hackmem(mulmod(uint256(message), sInv, n), mulmod(r, sInv, n), endcontract);\n\n        assembly {\n            X := addmod(X, sub(n, r), n)\n        }\n        return X == 0;\n    } //end  ecdsa_precomputed_verify()\n\n\n\n} //EOF\n"},"node_modules/@openzeppelin/contracts/contracts/utils/Base64.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.2) (utils/Base64.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     * See sections 4 and 5 of https://datatracker.ietf.org/doc/html/rfc4648\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    string internal constant _TABLE_URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE, true);\n    }\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64Url `string` representation.\n     */\n    function encodeURL(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE_URL, false);\n    }\n\n    /**\n     * @dev Internal table-agnostic conversion\n     */\n    function _encode(bytes memory data, string memory table, bool withPadding) private pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // If padding is enabled, the final length should be `bytes` data length divided by 3 rounded up and then\n        // multiplied by 4 so that it leaves room for padding the last chunk\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        // If padding is disabled, the final length should be `bytes` data length multiplied by 4/3 rounded up as\n        // opposed to when padding is required to fill the last chunk.\n        // - `4 *`              -> 4 characters for each chunk\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        uint256 resultLength = withPadding ? 4 * ((data.length + 2) / 3) : (4 * data.length + 2) / 3;\n\n        string memory result = new string(resultLength);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            if withPadding {\n                // When data `bytes` is not exactly 3 bytes long\n                // it is padded with `=` characters at the end\n                switch mod(mload(data), 3)\n                case 1 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                    mstore8(sub(resultPtr, 2), 0x3d)\n                }\n                case 2 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"},"node_modules/solady/src/utils/LibString.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(uint256(-value));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n)\n            let o := add(result, 0x20)\n            mstore(o, s)\n            mstore(add(o, n), 0)\n            mstore(0x40, add(result, 0x40))\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/cryptography/MessageHashUtils.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/ShortStrings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/interfaces/IERC5267.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/StorageSlot.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return a == 0 ? 0 : (a - 1) / b + 1;\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(denominator == 0 ? Panic.DIVISION_BY_ZERO : Panic.UNDER_OVERFLOW);\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, expect 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Ferma's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return x < 0 ? (n - uint256(-x)) : uint256(x); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked has failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/math/SignedMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/Panic.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/contracts/utils/math/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"}},"settings":{"remappings":["@prb/test/=node_modules/@prb/test/src/","forge-std/=node_modules/forge-std/src/","@openzeppelin/=node_modules/@openzeppelin/contracts/","@account-abstraction/=node_modules/accountabstraction/contracts/","solady/=node_modules/solady/src/","@web-authn/=node_modules/web-authn/src/","openzeppelin-contracts/=node_modules/@openzeppelin/contracts/","FreshCryptoLib/=node_modules/FreshCryptoLib/solidity/src/","src/=src/","account-abstraction/=node_modules/account-abstraction/contracts/","web-authn/=node_modules/web-authn/"],"optimizer":{"enabled":true,"runs":5000000},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"shanghai","viaIR":true,"libraries":{}}}
